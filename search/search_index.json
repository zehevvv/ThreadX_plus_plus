{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"about/","text":"Gravem discedentem contorto nostro virgine This project write by me... I currently work as embedded software engineer for more than 10 years, i have a lot of experience in ThreadX, and this project is the result of that. I hope someone will enjoy this code :)","title":"About"},{"location":"about/#gravem-discedentem-contorto-nostro-virgine","text":"This project write by me... I currently work as embedded software engineer for more than 10 years, i have a lot of experience in ThreadX, and this project is the result of that. I hope someone will enjoy this code :)","title":"Gravem discedentem contorto nostro virgine"},{"location":"home/","text":"ThreadX++ Introduction Hi all This is my little project, it's a big wrapper for ThreadX (AZURE RTOS) to work as c++, here some important pointes about the project: The main target of the project is one: SIMPLE, it's meaning that i do it much tiny that it can be, the price of course is that in way we lost abilities of the ThreadX I not cover all the API of ThreadX, I build this project on STM32H743, So if you using other processor of STM32 family i guess it will work, but if you have other MCU some of the abilities of my project will not available (like a watchdog) but you still can get most of the core function (you will need to change the code). Abilities The abilities of ThreadX++ Events-oriented: I added the events like delegate, so you can create event in one thread and register it from other thread. Object-oriented: most of the API of the ThreadX get warper of as class, hte list of the API Thread: Event: Event that one thread will create and other can register and wakeup one it invoke Mutex: Queue: Safe queue to send data between thread Semaphore: TimeEvent: Event that thread creating and the event will wake up the thread every amount time. MemoryPool: Easy way to create pool of memory (overriding \"new\" and \"delete\"). STM32 easy use: I also do some wrapper to very useful peripherals of ST: Watchdog: Simple watchdog Measure US: I used the \"DWT\" for create debug class that can easily measure time in microsecond Internal registry : Registry (like dictionary) that use to save data in the internal flash on the ST. Printf : Use the SWT port for printing much more effective. Where to start First you will need to install the ThreadX on your MCU, i made a tutorial for ST chips, if you have other MCU i also recommend to read it because it contain some configuration of the ThreadX that necessary. The main tutorials: Install ThreadX on ST","title":"Home"},{"location":"home/#threadx","text":"","title":"ThreadX++"},{"location":"home/#introduction","text":"Hi all This is my little project, it's a big wrapper for ThreadX (AZURE RTOS) to work as c++, here some important pointes about the project: The main target of the project is one: SIMPLE, it's meaning that i do it much tiny that it can be, the price of course is that in way we lost abilities of the ThreadX I not cover all the API of ThreadX, I build this project on STM32H743, So if you using other processor of STM32 family i guess it will work, but if you have other MCU some of the abilities of my project will not available (like a watchdog) but you still can get most of the core function (you will need to change the code).","title":"Introduction"},{"location":"home/#abilities","text":"The abilities of ThreadX++ Events-oriented: I added the events like delegate, so you can create event in one thread and register it from other thread. Object-oriented: most of the API of the ThreadX get warper of as class, hte list of the API Thread: Event: Event that one thread will create and other can register and wakeup one it invoke Mutex: Queue: Safe queue to send data between thread Semaphore: TimeEvent: Event that thread creating and the event will wake up the thread every amount time. MemoryPool: Easy way to create pool of memory (overriding \"new\" and \"delete\"). STM32 easy use: I also do some wrapper to very useful peripherals of ST: Watchdog: Simple watchdog Measure US: I used the \"DWT\" for create debug class that can easily measure time in microsecond Internal registry : Registry (like dictionary) that use to save data in the internal flash on the ST. Printf : Use the SWT port for printing much more effective.","title":"Abilities"},{"location":"home/#where-to-start","text":"First you will need to install the ThreadX on your MCU, i made a tutorial for ST chips, if you have other MCU i also recommend to read it because it contain some configuration of the ThreadX that necessary. The main tutorials: Install ThreadX on ST","title":"Where to start"},{"location":"Add_stm32_api/config_printf/","text":"Config printf git status git add git commit In file Core/Src/main.c insert the next code #ifdef __GNUC__ #define PUTCHAR_PROTOTYPE int __io_putchar(int ch) #else #define PUTCHAR_PROTOTYPE int fputc(int ch, FILE *f) #endif PUTCHAR_PROTOTYPE { // HAL_UART_Transmit(&huart3, (uint8_t *)&ch, 1, HAL_MAX_DELAY); ITM_SendChar(ch); return ch; } after the SystemClock_Config function call 2. Go to Run->Debug Configuration , new window open, go to tab Debugger , in the frame Serial Wire Viewer (SWv) you will found check box Enable , set it 3. Run the debugger and make him stop on breakpoint, than go to Window->Show View->Other , in the window that open search SWV ITM Data Console , this will add new view to your screen SWV ITM Data Console , in this view press on the settings New window will open, in the bottom you see frame ITM Stimulus Ports , you need to set the right checkbox that close to 0 and press OK 4. in the view SWV ITM Data Console press on the start trace button","title":"Config printf"},{"location":"Add_stm32_api/config_printf/#config-printf","text":"git status git add git commit In file Core/Src/main.c insert the next code #ifdef __GNUC__ #define PUTCHAR_PROTOTYPE int __io_putchar(int ch) #else #define PUTCHAR_PROTOTYPE int fputc(int ch, FILE *f) #endif PUTCHAR_PROTOTYPE { // HAL_UART_Transmit(&huart3, (uint8_t *)&ch, 1, HAL_MAX_DELAY); ITM_SendChar(ch); return ch; } after the SystemClock_Config function call 2. Go to Run->Debug Configuration , new window open, go to tab Debugger , in the frame Serial Wire Viewer (SWv) you will found check box Enable , set it 3. Run the debugger and make him stop on breakpoint, than go to Window->Show View->Other , in the window that open search SWV ITM Data Console , this will add new view to your screen SWV ITM Data Console , in this view press on the settings New window will open, in the bottom you see frame ITM Stimulus Ports , you need to set the right checkbox that close to 0 and press OK 4. in the view SWV ITM Data Console press on the start trace button","title":"Config printf"},{"location":"How_to_use/events/","text":"","title":"Events"},{"location":"How_to_use/introduction/","text":"Introduction The next page will help you to understand how to use create and use thread and communicate between them, it also include simple example of the basic API like Mutex, Semaphore... My recommend is to start with Task (Thread) page","title":"Introduction"},{"location":"How_to_use/introduction/#introduction","text":"The next page will help you to understand how to use create and use thread and communicate between them, it also include simple example of the basic API like Mutex, Semaphore... My recommend is to start with Task (Thread) page","title":"Introduction"},{"location":"How_to_use/task/","text":"Task Introduction In ThreadX++ the thread are task , so when you create task you actually create thread of ThreadX and how run code by task and send data between data and of course sleep. Create Task In this example we will create LedTask that blink the led every 1 second. 1) Add the include #include \"Task.h\" 2) Create a class that inherits from a Task class: class LedTask : public Task 3) In the implementation of the constructor you will need to call to constructor of the Task class and enter 3 parameter: name: The name of the task. priority: The priority of the task. stack size: The size of the stack of the task. In the next example we will create task with priority 10 and stack size 1024 : LedTask::LedTask() : Task(\"LedTask\", 10, 1024) { } Run code by task We have 4 way to run code from the created task: 1. Polling: Function that have endless loop ( while(1){} ). 2. Get message: A message that send by other thread can invoke the current thread to run specific function. 3. Event: Event is object that task can register to it by callback, when the event invoke -> every registered thread will run the call back. 4. Time event: This object that invoke callback of task after specific amount of time. Polling Every task have it's own \"main loop\", this is a function that have endless loop ( while(1){} ), in class Task you have internal function that call Main_loop() , this function run the endless loop: void Task::Main_loop() { while(1) { WaitForNewMessage(); } } If you want you can override this function by your class that inherited Task class, Important note: If you override, you must call to function WaitForNewMessage() , if you don't call it -> other thread can't send your thread messages, also all the events and time events will not invoke your task, the function WaitForNewMessage() can get parameter of timeout at milliseconds, so every time you want to sleep you can call this function with the time you want to sleep, you can see it in the next example: Example: in the next example the class ledTask will toggle the led every 500ms: void LedTask::Main_loop() { while(1) { ToggleLed(); WaitForNewMessage(500); } } Get message The message is the ability to send message from one task to second task, for example, let's assume that we have two task: LedTask and TestTask , we want that TestTask will send to LedTask message every seconds, in order to preform it we will need to do two things: 1) The TestTask need to call to member function bool NotifyMessage() of the LedTask every second, the function return if the message get into queue of message of LedTask successfully, Example: void TestTask::Main_loop() { while(1) { LedTaskPointer->NotifyMessage(); WaitForNewMessage(1000); } } 2) The LedTask need to override the function void ReceiveMsg(void* pointer) , example: void LedTask::ReceiveMsg(void* pointer) { printf(\"Get message \\n\",); } The result of code above is: every second the LedTask will print \"Get message\" Important Point: Get different messages: If you get more than one type of message (for example: if you have led and you want that LedTask can get message that turn on the led and message that turn off the led) it can be a problem because you can't know with type of message you get, to solve that problem you will need to send data in this message and the LedTask need to know to parse the data, I will explain it in section Send data between tasks . Event Event is object that task can register to it by callback, when the event invoke -> every registered thread will run the call back, For the next example let assume that we have 2 task: LedTask and TestTask , we want that TestTask have event that LedTask can register to it and every one second the TestTask will invoke the Event. Todo that we need 4 steps: 1) Create the event object in TestTask: #include \"Event.h\" class TestTask : public Task { public: TestTask(); void Main_loop(); Event event; }; 2) Create callback in the LedTask: class LedTask : public Task { public: LedTask(); void Main_loop(); void Callback(void* param) { printf(\"Event invoke \\n\"); } }; Note: You can change the name of the callback as you like but it must be in the next pattern void <Function name>(void* pointer) 3) Register the LedTask to event of TestTask: void LedTask::Main_loop() { TestTaskPointer->event.Register(&LedTask::Callback, this, this); while(1) WaitForNewMessage() } Parameter explain: The register function of the event get 3 parameters: Function: Pointer to function. Class pointer: Pointer to class that have the callback (in my example is pointer to LedTask) Task pointer: Pointer to class that inherited from task class (in my example is pointer to LedTask) 4) Invoke the event every one second: void TestTask::Main_loop() { event.Invoke() while(1) WaitForNewMessage(1000) } The result of the code is every second the LedTask will print \"Event invoke\" Time event This object that invoke callback of task after specific amount of time, For next example let's assume that we had one task: LedTask and we want to toggle the led every 100ms, to do that we need to preform 2 steps: 1) Create callback: void LedTask::Callback(void* param) { printf(\"Toggle led \\n\") } Note: You can change the name of the callback as you like but it must be in the next pattern void <Function name>(void* pointer) 2) Create the event: #include \"TimeEvent.h\" void LedTask::Main_loop() { TimeEvent time_event(&LedTask::Callback, this, this, 100, true) while(1) WaitForNewMessage(); } Parameter explain: The register function of the event get 5 parameters: Function: Pointer to function. Class pointer: Pointer to class that have the callback (in my example is pointer to LedTask) Task pointer: Pointer to class that inherited from task class (in my example is pointer to LedTask) Time to execute: The number of milliseconds until call to callback. Is periodic: Boolean, false - The callback call once, true - call periodic (forever). Send data between tasks","title":"Task (Thread)"},{"location":"How_to_use/task/#task","text":"","title":"Task"},{"location":"How_to_use/task/#introduction","text":"In ThreadX++ the thread are task , so when you create task you actually create thread of ThreadX and how run code by task and send data between data and of course sleep.","title":"Introduction"},{"location":"How_to_use/task/#create-task","text":"In this example we will create LedTask that blink the led every 1 second. 1) Add the include #include \"Task.h\" 2) Create a class that inherits from a Task class: class LedTask : public Task 3) In the implementation of the constructor you will need to call to constructor of the Task class and enter 3 parameter: name: The name of the task. priority: The priority of the task. stack size: The size of the stack of the task. In the next example we will create task with priority 10 and stack size 1024 : LedTask::LedTask() : Task(\"LedTask\", 10, 1024) { }","title":"Create Task"},{"location":"How_to_use/task/#run-code-by-task","text":"We have 4 way to run code from the created task: 1. Polling: Function that have endless loop ( while(1){} ). 2. Get message: A message that send by other thread can invoke the current thread to run specific function. 3. Event: Event is object that task can register to it by callback, when the event invoke -> every registered thread will run the call back. 4. Time event: This object that invoke callback of task after specific amount of time.","title":"Run code by task"},{"location":"How_to_use/task/#polling","text":"Every task have it's own \"main loop\", this is a function that have endless loop ( while(1){} ), in class Task you have internal function that call Main_loop() , this function run the endless loop: void Task::Main_loop() { while(1) { WaitForNewMessage(); } } If you want you can override this function by your class that inherited Task class, Important note: If you override, you must call to function WaitForNewMessage() , if you don't call it -> other thread can't send your thread messages, also all the events and time events will not invoke your task, the function WaitForNewMessage() can get parameter of timeout at milliseconds, so every time you want to sleep you can call this function with the time you want to sleep, you can see it in the next example: Example: in the next example the class ledTask will toggle the led every 500ms: void LedTask::Main_loop() { while(1) { ToggleLed(); WaitForNewMessage(500); } }","title":"Polling"},{"location":"How_to_use/task/#get-message","text":"The message is the ability to send message from one task to second task, for example, let's assume that we have two task: LedTask and TestTask , we want that TestTask will send to LedTask message every seconds, in order to preform it we will need to do two things: 1) The TestTask need to call to member function bool NotifyMessage() of the LedTask every second, the function return if the message get into queue of message of LedTask successfully, Example: void TestTask::Main_loop() { while(1) { LedTaskPointer->NotifyMessage(); WaitForNewMessage(1000); } } 2) The LedTask need to override the function void ReceiveMsg(void* pointer) , example: void LedTask::ReceiveMsg(void* pointer) { printf(\"Get message \\n\",); } The result of code above is: every second the LedTask will print \"Get message\" Important Point: Get different messages: If you get more than one type of message (for example: if you have led and you want that LedTask can get message that turn on the led and message that turn off the led) it can be a problem because you can't know with type of message you get, to solve that problem you will need to send data in this message and the LedTask need to know to parse the data, I will explain it in section Send data between tasks .","title":"Get message"},{"location":"How_to_use/task/#event","text":"Event is object that task can register to it by callback, when the event invoke -> every registered thread will run the call back, For the next example let assume that we have 2 task: LedTask and TestTask , we want that TestTask have event that LedTask can register to it and every one second the TestTask will invoke the Event. Todo that we need 4 steps: 1) Create the event object in TestTask: #include \"Event.h\" class TestTask : public Task { public: TestTask(); void Main_loop(); Event event; }; 2) Create callback in the LedTask: class LedTask : public Task { public: LedTask(); void Main_loop(); void Callback(void* param) { printf(\"Event invoke \\n\"); } }; Note: You can change the name of the callback as you like but it must be in the next pattern void <Function name>(void* pointer) 3) Register the LedTask to event of TestTask: void LedTask::Main_loop() { TestTaskPointer->event.Register(&LedTask::Callback, this, this); while(1) WaitForNewMessage() } Parameter explain: The register function of the event get 3 parameters: Function: Pointer to function. Class pointer: Pointer to class that have the callback (in my example is pointer to LedTask) Task pointer: Pointer to class that inherited from task class (in my example is pointer to LedTask) 4) Invoke the event every one second: void TestTask::Main_loop() { event.Invoke() while(1) WaitForNewMessage(1000) } The result of the code is every second the LedTask will print \"Event invoke\"","title":"Event"},{"location":"How_to_use/task/#time-event","text":"This object that invoke callback of task after specific amount of time, For next example let's assume that we had one task: LedTask and we want to toggle the led every 100ms, to do that we need to preform 2 steps: 1) Create callback: void LedTask::Callback(void* param) { printf(\"Toggle led \\n\") } Note: You can change the name of the callback as you like but it must be in the next pattern void <Function name>(void* pointer) 2) Create the event: #include \"TimeEvent.h\" void LedTask::Main_loop() { TimeEvent time_event(&LedTask::Callback, this, this, 100, true) while(1) WaitForNewMessage(); } Parameter explain: The register function of the event get 5 parameters: Function: Pointer to function. Class pointer: Pointer to class that have the callback (in my example is pointer to LedTask) Task pointer: Pointer to class that inherited from task class (in my example is pointer to LedTask) Time to execute: The number of milliseconds until call to callback. Is periodic: Boolean, false - The callback call once, true - call periodic (forever).","title":"Time event"},{"location":"How_to_use/task/#send-data-between-tasks","text":"","title":"Send data between tasks"},{"location":"How_to_use/time_events/","text":"","title":"Timer events"},{"location":"Install/add_threadx_plus_plus/","text":"Add ThreadX++ Introduction In this tutorial we add the ThreadX++ to project Add ThreadX++ Clone the ThreadX++ Link Copy the folder \"ThreadX++\" to your project. Now we need to add ThreadX++ to include path and source path (this step is explain in CUBE IDE, if you work on other IDE you need to figure this step yourself... good luck), In CUBE IDE go to \"Project->Properties\", new window will open, in the left side of the window go to \"C/C++ Build->Settings\", select tab \"Tool Settings\", go to \"MCU G++ Compiler->Include paths\", in the window you will see list of the included path, Add the path to ThreadX++/inc folder, you also need to do the same in \"MCU G++ Compiler->Include paths\". Now return to left side of the window and select \"C/C++ General->Paths and Symbols\" than select tab \"Source Location\" and add the folder ThreadX++/src In this step we call the function that add the ThreadX++ to system, Go to file \"AZURE_RTOS/Ap/app_azure_rtos.c\" and add the include \" #include <StartThreadX++.h> \" than add the call of the function StartThreadXPlusPlus(first_unused_memory); after the call of function App_ThreadX_Init","title":"Add ThreadX++"},{"location":"Install/add_threadx_plus_plus/#add-threadx","text":"","title":"Add ThreadX++"},{"location":"Install/add_threadx_plus_plus/#introduction","text":"In this tutorial we add the ThreadX++ to project","title":"Introduction"},{"location":"Install/add_threadx_plus_plus/#add-threadx_1","text":"Clone the ThreadX++ Link Copy the folder \"ThreadX++\" to your project. Now we need to add ThreadX++ to include path and source path (this step is explain in CUBE IDE, if you work on other IDE you need to figure this step yourself... good luck), In CUBE IDE go to \"Project->Properties\", new window will open, in the left side of the window go to \"C/C++ Build->Settings\", select tab \"Tool Settings\", go to \"MCU G++ Compiler->Include paths\", in the window you will see list of the included path, Add the path to ThreadX++/inc folder, you also need to do the same in \"MCU G++ Compiler->Include paths\". Now return to left side of the window and select \"C/C++ General->Paths and Symbols\" than select tab \"Source Location\" and add the folder ThreadX++/src In this step we call the function that add the ThreadX++ to system, Go to file \"AZURE_RTOS/Ap/app_azure_rtos.c\" and add the include \" #include <StartThreadX++.h> \" than add the call of the function StartThreadXPlusPlus(first_unused_memory); after the call of function App_ThreadX_Init","title":"Add ThreadX++"},{"location":"Install/install_st/","text":"Install ThreadX on ST Introduction In this tutorial we will install ThreadX by using the CUBE IDE, first you need to install CUBE IDE than open project, after that you can install the ThreadX. I write tutorial but you not must to use them, you can find a lot of tutorials in google. Install CUBE IDE You can download the CUBE IDE from here: Link You also need to download CUBE MX: Link Open project Open Cube IDE Go to \"File->New->STM32 project\" New window will open, in field \"Commercial Part Number\" you need to add your STM32 model (\"for example my is STM32H743ZIT6\"), in the right bottom of the screen you will see list of STM32 modules, select your model from the list, on bottom of screen press on the \"Next >\" New window will open, in the field \"Targeted Language\" select \"C++\", and in the field \"Project Name:\" Write the name of the your project, press on the \"Finish\" button. New window Eil ask if you want memory Protection, use your brain and press \"Yes\". Now wait, it can take sometimes, in the end you will get the next screen Add ThreadX In the screen you need to select the tab \"Pinout & configuration\" and select \"Software Packs\", than select \"Manage software packs\" New window will open, select tab \"STMicroelectronics\", in this tab you need to find \"X-CUBE-AZRTOS-XX\" (\"XX\" is the name of your family model, for example my is \"H7\"), than select it and it open list of package, you need to check the \" Azure RTOS STM32Cube expansion package for STM32XX series\" (again \"XX\" is the name of your family model), than press install After the download finish, Now you need to return to main screen and again select the tab \"Pinout & configuration\" and select \"Software Packs\", but now select the \"Select Components\" New window will open, you will see list of all the pack you and add to your project, you need to select \"STMicroelectronics.X-CUBE-AZRTOS-XX\"(again \"XX\" is the name of your family model)-> RTOS ThreadX-> ThreadX, than select the checkbox of \"Core\" , Note: If \"STMicroelectronics.X-CUBE-AZRTOS-XX\" is gray press on install, after the install select it. On the main screen on the left side you see list of option, select \"Middleware and Software Packs\", it open a list, than select \"X-CUBE-AZRTOS-XX\", it open new screen, check the box of field \"RTOS ThreadX\" , Save the file (go to File->Save), the IDE will generate the code, the first time will take sometime. Next step Now you ready to start with the real thing! Add ThreadX++ .","title":"Install ThreadX on ST"},{"location":"Install/install_st/#install-threadx-on-st","text":"","title":"Install ThreadX on ST"},{"location":"Install/install_st/#introduction","text":"In this tutorial we will install ThreadX by using the CUBE IDE, first you need to install CUBE IDE than open project, after that you can install the ThreadX. I write tutorial but you not must to use them, you can find a lot of tutorials in google.","title":"Introduction"},{"location":"Install/install_st/#install-cube-ide","text":"You can download the CUBE IDE from here: Link You also need to download CUBE MX: Link","title":"Install CUBE IDE"},{"location":"Install/install_st/#open-project","text":"Open Cube IDE Go to \"File->New->STM32 project\" New window will open, in field \"Commercial Part Number\" you need to add your STM32 model (\"for example my is STM32H743ZIT6\"), in the right bottom of the screen you will see list of STM32 modules, select your model from the list, on bottom of screen press on the \"Next >\" New window will open, in the field \"Targeted Language\" select \"C++\", and in the field \"Project Name:\" Write the name of the your project, press on the \"Finish\" button. New window Eil ask if you want memory Protection, use your brain and press \"Yes\". Now wait, it can take sometimes, in the end you will get the next screen","title":"Open project"},{"location":"Install/install_st/#add-threadx","text":"In the screen you need to select the tab \"Pinout & configuration\" and select \"Software Packs\", than select \"Manage software packs\" New window will open, select tab \"STMicroelectronics\", in this tab you need to find \"X-CUBE-AZRTOS-XX\" (\"XX\" is the name of your family model, for example my is \"H7\"), than select it and it open list of package, you need to check the \" Azure RTOS STM32Cube expansion package for STM32XX series\" (again \"XX\" is the name of your family model), than press install After the download finish, Now you need to return to main screen and again select the tab \"Pinout & configuration\" and select \"Software Packs\", but now select the \"Select Components\" New window will open, you will see list of all the pack you and add to your project, you need to select \"STMicroelectronics.X-CUBE-AZRTOS-XX\"(again \"XX\" is the name of your family model)-> RTOS ThreadX-> ThreadX, than select the checkbox of \"Core\" , Note: If \"STMicroelectronics.X-CUBE-AZRTOS-XX\" is gray press on install, after the install select it. On the main screen on the left side you see list of option, select \"Middleware and Software Packs\", it open a list, than select \"X-CUBE-AZRTOS-XX\", it open new screen, check the box of field \"RTOS ThreadX\" , Save the file (go to File->Save), the IDE will generate the code, the first time will take sometime.","title":"Add ThreadX"},{"location":"Install/install_st/#next-step","text":"Now you ready to start with the real thing! Add ThreadX++ .","title":"Next step"}]}