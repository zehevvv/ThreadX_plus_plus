{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"ThreadX++ Introduction Hi all This is my little project, it's a big wrapper for ThreadX (AZURE RTOS) to work as c++, here some important pointes about the project: The main target of the project is one: SIMPLE, it's meaning that i do it much tiny that it can be, the price of course is that in way we lost abilities of the ThreadX I not cover all the API of ThreadX, I build this project on STM32H743, So if you using other processor of STM32 family i guess it will work, but if you have other MCU some of the abilities of my project will not available (like a watchdog) but you still can get most of the core function (you will need to change the code). Abilities The abilities of ThreadX++ Events-oriented: I added the events like delegate, so you can create event in one thread and register it from other thread. Object-oriented: most of the API of the ThreadX get warper of as class, hte list of the API Thread: Event: Event that one thread will create and other can register and wakeup one it invoke Mutex: Queue: Safe queue to send data between thread Semaphore: TimeEvent: Event that thread creating and the event will wake up the thread every amount time. MemoryPool: Easy way to create pool of memory (overriding \"new\" and \"delete\"). STM32 easy use: I also do some wrapper to very useful peripherals of ST: Watchdog: Simple watchdog Measure US: I used the \"DWT\" for create debug class that can easily measure time in microsecond Internal registry : Registry (like dictionary) that use to save data in the internal flash on the ST. Printf : Use the SWT port for printing much more effective. Where to start First you will need to install the ThreadX on your MCU, i made a tutorial for ST chips, if you have other MCU i also recommend to read it because it contain some configuration of the ThreadX that necessary. The main tutorials: Install ThreadX on ST","title":"Home"},{"location":"#threadx","text":"","title":"ThreadX++"},{"location":"#introduction","text":"Hi all This is my little project, it's a big wrapper for ThreadX (AZURE RTOS) to work as c++, here some important pointes about the project: The main target of the project is one: SIMPLE, it's meaning that i do it much tiny that it can be, the price of course is that in way we lost abilities of the ThreadX I not cover all the API of ThreadX, I build this project on STM32H743, So if you using other processor of STM32 family i guess it will work, but if you have other MCU some of the abilities of my project will not available (like a watchdog) but you still can get most of the core function (you will need to change the code).","title":"Introduction"},{"location":"#abilities","text":"The abilities of ThreadX++ Events-oriented: I added the events like delegate, so you can create event in one thread and register it from other thread. Object-oriented: most of the API of the ThreadX get warper of as class, hte list of the API Thread: Event: Event that one thread will create and other can register and wakeup one it invoke Mutex: Queue: Safe queue to send data between thread Semaphore: TimeEvent: Event that thread creating and the event will wake up the thread every amount time. MemoryPool: Easy way to create pool of memory (overriding \"new\" and \"delete\"). STM32 easy use: I also do some wrapper to very useful peripherals of ST: Watchdog: Simple watchdog Measure US: I used the \"DWT\" for create debug class that can easily measure time in microsecond Internal registry : Registry (like dictionary) that use to save data in the internal flash on the ST. Printf : Use the SWT port for printing much more effective.","title":"Abilities"},{"location":"#where-to-start","text":"First you will need to install the ThreadX on your MCU, i made a tutorial for ST chips, if you have other MCU i also recommend to read it because it contain some configuration of the ThreadX that necessary. The main tutorials: Install ThreadX on ST","title":"Where to start"},{"location":"about/","text":"Gravem discedentem contorto nostro virgine This project write by me... I currently work as embedded software engineer for more than 10 years, i have a lot of experience in ThreadX, and this project is the result of that. I hope someone will enjoy this code :)","title":"About"},{"location":"about/#gravem-discedentem-contorto-nostro-virgine","text":"This project write by me... I currently work as embedded software engineer for more than 10 years, i have a lot of experience in ThreadX, and this project is the result of that. I hope someone will enjoy this code :)","title":"Gravem discedentem contorto nostro virgine"},{"location":"Add_stm32_api/config_printf/","text":"Config printf introduction The normal debug print is run over the UART of the debugger, if you want you also can send them over the SWV, the SWV is part of the debugger and it enables several features, one of them being the port , that line that you send data, in this tutorial, you will learn how to config the printf to connect to port 0 . Key features: Speed: It's much quicker than the UART, (the default UART is 128kb, and the SWV is most of the time the same speed as the system clock). Not need UART: If you use the SWV, you can use the UART for other tasks. Cube integration: Cube IDE is based on Eclipse, Eclipse has view control for the ports feature of the SWV. Config In the file Core/Src/main.c insert the next code #ifdef __GNUC__ #define PUTCHAR_PROTOTYPE int __io_putchar(int ch) #else #define PUTCHAR_PROTOTYPE int fputc(int ch, FILE *f) #endif PUTCHAR_PROTOTYPE { // HAL_UART_Transmit(&huart3, (uint8_t *)&ch, 1, HAL_MAX_DELAY); ITM_SendChar(ch); return ch; } after the SystemClock_Config function call 2. Go to Run->Debug Configuration , and a new window opens, go to tab Debugger , and in the frame Serial Wire Viewer (SWv) you will find the check box Enable , set it 3. Run the debugger and make him stop on a breakpoint, then go to Window->Show View->Other , in the window that opens search SWV ITM Data Console , this will add a new view to your screen SWV ITM Data Console , in this view press on the settings New window will open, in the bottom you see the frame ITM Stimulus Ports , you need to set the right checkbox that is near the 0 and press OK 4. in the view SWV ITM Data Console press on the start trace button (it looks like the red or gray ball)","title":"Config printf"},{"location":"Add_stm32_api/config_printf/#config-printf","text":"","title":"Config printf"},{"location":"Add_stm32_api/config_printf/#introduction","text":"The normal debug print is run over the UART of the debugger, if you want you also can send them over the SWV, the SWV is part of the debugger and it enables several features, one of them being the port , that line that you send data, in this tutorial, you will learn how to config the printf to connect to port 0 .","title":"introduction"},{"location":"Add_stm32_api/config_printf/#key-features","text":"Speed: It's much quicker than the UART, (the default UART is 128kb, and the SWV is most of the time the same speed as the system clock). Not need UART: If you use the SWV, you can use the UART for other tasks. Cube integration: Cube IDE is based on Eclipse, Eclipse has view control for the ports feature of the SWV.","title":"Key features:"},{"location":"Add_stm32_api/config_printf/#config","text":"In the file Core/Src/main.c insert the next code #ifdef __GNUC__ #define PUTCHAR_PROTOTYPE int __io_putchar(int ch) #else #define PUTCHAR_PROTOTYPE int fputc(int ch, FILE *f) #endif PUTCHAR_PROTOTYPE { // HAL_UART_Transmit(&huart3, (uint8_t *)&ch, 1, HAL_MAX_DELAY); ITM_SendChar(ch); return ch; } after the SystemClock_Config function call 2. Go to Run->Debug Configuration , and a new window opens, go to tab Debugger , and in the frame Serial Wire Viewer (SWv) you will find the check box Enable , set it 3. Run the debugger and make him stop on a breakpoint, then go to Window->Show View->Other , in the window that opens search SWV ITM Data Console , this will add a new view to your screen SWV ITM Data Console , in this view press on the settings New window will open, in the bottom you see the frame ITM Stimulus Ports , you need to set the right checkbox that is near the 0 and press OK 4. in the view SWV ITM Data Console press on the start trace button (it looks like the red or gray ball)","title":"Config"},{"location":"Add_stm32_api/measure_time/","text":"Measure time This debug object gives you the ability to measure time in microseconds units. Create First, you need to enable the \"DWT\" (this is the peripheral that uses to measure time), to do so you need to go to HW.h file and uncomment next define: #define DWT_ENABLE Then go to where you want to measure the time and create the measure time object: #include \"Debug.h\" Debug::MeasureTime my_measure_time; How to use When you want to start measuring you need to call to Start() function, and when you want to end call to End() function, the function End() returns the delta in microseconds units, Example: my_measure_time.Start(); SomeFunction(); uint32_t result = my_measure_time.End(); printf(\"The delta is %lu \\n\", result); Note: You need to know that the measured time is getting data from the counter that works on 32-bit register, so it may cause to wraparound.","title":"Measure time"},{"location":"Add_stm32_api/measure_time/#measure-time","text":"This debug object gives you the ability to measure time in microseconds units.","title":"Measure time"},{"location":"Add_stm32_api/measure_time/#create","text":"First, you need to enable the \"DWT\" (this is the peripheral that uses to measure time), to do so you need to go to HW.h file and uncomment next define: #define DWT_ENABLE Then go to where you want to measure the time and create the measure time object: #include \"Debug.h\" Debug::MeasureTime my_measure_time;","title":"Create"},{"location":"Add_stm32_api/measure_time/#how-to-use","text":"When you want to start measuring you need to call to Start() function, and when you want to end call to End() function, the function End() returns the delta in microseconds units, Example: my_measure_time.Start(); SomeFunction(); uint32_t result = my_measure_time.End(); printf(\"The delta is %lu \\n\", result); Note: You need to know that the measured time is getting data from the counter that works on 32-bit register, so it may cause to wraparound.","title":"How to use"},{"location":"Add_stm32_api/registry/","text":"Registry This is an object that can save data on the internal flash Properties Logic block: The registry gets the sector of flash and divides it into \"logic blocks\" and every time we want to store data it writes it to the next empty block. Fault protected: The register is protected from unexpected shutdown and can recognize corrupted blocks. Performance: The registry is built with caching, because of that when a task needs to write and read it's not going to flash and it takes no time, the registry has a task to work in the shadow to update the flash. Memory: Because of the caching the repository hold buffers so it's not cheap, but because of the caching the registry does not need to allocate new memory for every write of the registry. Minimum size: The registry needs a minimum number of 2 sectors. Memory efficiency: The block size reduces by the header of 16 bytes. Erase value: Currently the registry can't erase values... ): Write buffer: The registry support of writing buffer but the size of the buffer must be constant. Enable the registry 1) Go to HW.h file and you need to add a number of defines: INTERNAL_REGISTRY_ENABLE: INTERNAL_REGISTRY_TASK_PRIORITY: The priority of the task that updates the flash when the cache is changed. INTERNAL_FLASH_FLASHWORD: This unit is the number of bytes that flash write every step. INTERNAL_FLASH_SECTOR_SIZE: The size of the sector of flash INTERNAL_REGISTRY_START_ADDRESS: At The start of the registry, you need to get attention to two things, one is that you do not overwrite the code of the MCU so the address will be of a sector that is not in use, and the second is you need to check if you have enough space, the calculation is (start address + num sector * size sector). INTERNAL_REGISTRY_NUM_SECTOR The num of the sectors, the minimum size is 2. INTERNAL_REGISTRY_LOGICAL_BLOCK_SIZE: The block size need to be divide \"INTERNAL_FLASH_SECTOR_SIZE\" into blocks, is must divide without remainder. Example: let's assume that we work on the internal flash of STM32H743 so the FLASHWORD is 8 and the sector size is 0x20000 (131,072) bytes, also let's assume that we want only 2 sectors, and we want to use the lasts sectors, and we want the block size of 512 bytes (so the actual size for writing will be 512 - 16 = 496), so the number of logics blocks is 0x20000 * 2 / 512 = 512 blocks, so the defines will be: #define INTERNAL_REGISTRY_ENABLE #define INTERNAL_REGISTRY_TASK_PRIORITY (15) #define INTERNAL_REGISTRY_START_ADDRESS (0x081C0000) #define INTERNAL_REGISTRY_NUM_SECTOR (2) #define INTERNAL_REGISTRY_LOGICAL_BLOCK_SIZE (512) #define INTERNAL_FLASH_FLASHWORD (8) #define INTERNAL_FLASH_SECTOR_SIZE (0x20000) 2) Go to file TasksManager.cpp , in the function Tasks_manager_start() add the registry: #include \"InternalRegistry.h\" void Tasks_manager_start() { InternalRegistry::Instance()->StartTask(); How to use The registry function: Write Defamation: template <typename T> void Write(char* name, uint8_t name_size, T value) Parameters: name: The key, a string of the name of the value. name_size: The size of the string. value: The value that want to save to Flash, the value is a template so it can be any type. Example: Write type int with value 7 with key name val_1 int value = 7; InternalRegistry::Instance()->Write((char*)\"val_1\", 5, value); Write buffer Defamation: void WriteBuffer(char* name, uint8_t name_size, uint8_t* buffer, uint8_t buffer_size); Parameters: name: The key, a string of the name of the value. name_size: The size of the string. buffer: Pointer to a buffer that you want to write. buffer_size: Size of the buffer. Example: Write buffer of {1, 2, 3} with key name buf_12 uint8_t buffer[3] = {1, 2, 3} InternalRegistry::Instance()->WriteBuffer((char*)\"buf_12\", 6, buffer, 3); Read Defamation: template <typename T> bool Read(char* name, uint8_t name_size, T& value) Parameters: name: The key, a string of the name of the value. name_size: The size of the string. value: [out] The value that wants to read from the flash, the value is a template so it can be any type. return value: Boolean, true - read success. Example: Read type int with key name val_1 , the value will store in variable value : int value; InternalRegistry::Instance()->Read((char*)\"val_1\", 5, value); Read buffer Defamation: bool ReadBuffer(char* name, uint8_t name_size, uint8_t* buffer, uint8_t buffer_size); Parameters: name: The key, a string of the name of the value. name_size: The size of the string. buffer: Pointer to a buffer that stores the data from. buffer_size: Size of the buffer. return value: Boolean, true - read success. Example: Read buffer of 3 bytes, with key name buf_12 uint8_t buffer[3]; InternalRegistry::Instance()->WriteBuffer((char*)\"buf_12\", 6, buffer, 3); Is exist Return if the name of the value (and the value) exist in the flash. Defamation: bool IsExist(char* name, uint8_t name_size); Parameters: name: The key, a string of the name of the value. name_size: The size of the string. return value: Boolean, true - the name exists. Example: Check if existing value with the name buf_12 bool is_exist = InternalRegistry::Instance()->IsExist((char*)\"buf_12\", 6); Print all Print all the values that store in flash Defamation: bool IsExist(char* name, uint8_t name_size); Example: InternalRegistry::Instance()->PrintAll();","title":"Registry"},{"location":"Add_stm32_api/registry/#registry","text":"This is an object that can save data on the internal flash","title":"Registry"},{"location":"Add_stm32_api/registry/#properties","text":"Logic block: The registry gets the sector of flash and divides it into \"logic blocks\" and every time we want to store data it writes it to the next empty block. Fault protected: The register is protected from unexpected shutdown and can recognize corrupted blocks. Performance: The registry is built with caching, because of that when a task needs to write and read it's not going to flash and it takes no time, the registry has a task to work in the shadow to update the flash. Memory: Because of the caching the repository hold buffers so it's not cheap, but because of the caching the registry does not need to allocate new memory for every write of the registry. Minimum size: The registry needs a minimum number of 2 sectors. Memory efficiency: The block size reduces by the header of 16 bytes. Erase value: Currently the registry can't erase values... ): Write buffer: The registry support of writing buffer but the size of the buffer must be constant.","title":"Properties"},{"location":"Add_stm32_api/registry/#enable-the-registry","text":"1) Go to HW.h file and you need to add a number of defines: INTERNAL_REGISTRY_ENABLE: INTERNAL_REGISTRY_TASK_PRIORITY: The priority of the task that updates the flash when the cache is changed. INTERNAL_FLASH_FLASHWORD: This unit is the number of bytes that flash write every step. INTERNAL_FLASH_SECTOR_SIZE: The size of the sector of flash INTERNAL_REGISTRY_START_ADDRESS: At The start of the registry, you need to get attention to two things, one is that you do not overwrite the code of the MCU so the address will be of a sector that is not in use, and the second is you need to check if you have enough space, the calculation is (start address + num sector * size sector). INTERNAL_REGISTRY_NUM_SECTOR The num of the sectors, the minimum size is 2. INTERNAL_REGISTRY_LOGICAL_BLOCK_SIZE: The block size need to be divide \"INTERNAL_FLASH_SECTOR_SIZE\" into blocks, is must divide without remainder. Example: let's assume that we work on the internal flash of STM32H743 so the FLASHWORD is 8 and the sector size is 0x20000 (131,072) bytes, also let's assume that we want only 2 sectors, and we want to use the lasts sectors, and we want the block size of 512 bytes (so the actual size for writing will be 512 - 16 = 496), so the number of logics blocks is 0x20000 * 2 / 512 = 512 blocks, so the defines will be: #define INTERNAL_REGISTRY_ENABLE #define INTERNAL_REGISTRY_TASK_PRIORITY (15) #define INTERNAL_REGISTRY_START_ADDRESS (0x081C0000) #define INTERNAL_REGISTRY_NUM_SECTOR (2) #define INTERNAL_REGISTRY_LOGICAL_BLOCK_SIZE (512) #define INTERNAL_FLASH_FLASHWORD (8) #define INTERNAL_FLASH_SECTOR_SIZE (0x20000) 2) Go to file TasksManager.cpp , in the function Tasks_manager_start() add the registry: #include \"InternalRegistry.h\" void Tasks_manager_start() { InternalRegistry::Instance()->StartTask();","title":"Enable the registry"},{"location":"Add_stm32_api/registry/#how-to-use","text":"The registry function:","title":"How to use"},{"location":"Add_stm32_api/registry/#write","text":"Defamation: template <typename T> void Write(char* name, uint8_t name_size, T value) Parameters: name: The key, a string of the name of the value. name_size: The size of the string. value: The value that want to save to Flash, the value is a template so it can be any type. Example: Write type int with value 7 with key name val_1 int value = 7; InternalRegistry::Instance()->Write((char*)\"val_1\", 5, value);","title":"Write"},{"location":"Add_stm32_api/registry/#write-buffer","text":"Defamation: void WriteBuffer(char* name, uint8_t name_size, uint8_t* buffer, uint8_t buffer_size); Parameters: name: The key, a string of the name of the value. name_size: The size of the string. buffer: Pointer to a buffer that you want to write. buffer_size: Size of the buffer. Example: Write buffer of {1, 2, 3} with key name buf_12 uint8_t buffer[3] = {1, 2, 3} InternalRegistry::Instance()->WriteBuffer((char*)\"buf_12\", 6, buffer, 3);","title":"Write buffer"},{"location":"Add_stm32_api/registry/#read","text":"Defamation: template <typename T> bool Read(char* name, uint8_t name_size, T& value) Parameters: name: The key, a string of the name of the value. name_size: The size of the string. value: [out] The value that wants to read from the flash, the value is a template so it can be any type. return value: Boolean, true - read success. Example: Read type int with key name val_1 , the value will store in variable value : int value; InternalRegistry::Instance()->Read((char*)\"val_1\", 5, value);","title":"Read"},{"location":"Add_stm32_api/registry/#read-buffer","text":"Defamation: bool ReadBuffer(char* name, uint8_t name_size, uint8_t* buffer, uint8_t buffer_size); Parameters: name: The key, a string of the name of the value. name_size: The size of the string. buffer: Pointer to a buffer that stores the data from. buffer_size: Size of the buffer. return value: Boolean, true - read success. Example: Read buffer of 3 bytes, with key name buf_12 uint8_t buffer[3]; InternalRegistry::Instance()->WriteBuffer((char*)\"buf_12\", 6, buffer, 3);","title":"Read buffer"},{"location":"Add_stm32_api/registry/#is-exist","text":"Return if the name of the value (and the value) exist in the flash. Defamation: bool IsExist(char* name, uint8_t name_size); Parameters: name: The key, a string of the name of the value. name_size: The size of the string. return value: Boolean, true - the name exists. Example: Check if existing value with the name buf_12 bool is_exist = InternalRegistry::Instance()->IsExist((char*)\"buf_12\", 6);","title":"Is exist"},{"location":"Add_stm32_api/registry/#print-all","text":"Print all the values that store in flash Defamation: bool IsExist(char* name, uint8_t name_size); Example: InternalRegistry::Instance()->PrintAll();","title":"Print all"},{"location":"Add_stm32_api/watchdog/","text":"Watchdog I create a class of watchdog that works on the IWDG1 internal watchdog, this watchdog needs to pet every amount of time that config at init, Enable the watchdog 1) Go to HW.h file and set the next 3 defines: WATCHDOG_ENABLE : WATCHDOG_TIMEOUT_MS : The max amount of time (milliseconds) that if the watchdog does not pet (reload) -> the watchdog will restart the MCU, WATCHDOG_PET_MS : The time between pet (reload). WATCHDOG_TASK_PRIORITY : The priority of the watchdog task the reload (pet) of the watchdog, should be the less prioritized task. Example: if we want that watchdog will reset the MCU if it does not pet more than 100ms, also we want that our watchdog service will pet the watchdog every 90ms, so the definition should be like this: #define WATCHDOG_ENABLE #define WATCHDOG_TIMEOUT_MS (100) #define WATCHDOG_PET_MS (90) #define WATCHDOG_TASK_PRIORITY (14) 2) Go to file TasksManager.cpp , in the function Tasks_manager_start() add the watchdog: #include \"Watchdog.h\" void Tasks_manager_start() { Watchdog::Instance()->StartTask(); note The watchdog priority is should be the lowest that possible but you need to careful to not be in the same or low priority of the task that will take more time than define WATCHDOG_TIMEOUT_MS The watchdog must not enable when you want to debug your system and stop the run, the watchdog will kill you. When you set the system to sleep, you must somehow pet the watchdog because it works on the LSI clock and not on the main clock.","title":"Watchdog"},{"location":"Add_stm32_api/watchdog/#watchdog","text":"I create a class of watchdog that works on the IWDG1 internal watchdog, this watchdog needs to pet every amount of time that config at init,","title":"Watchdog"},{"location":"Add_stm32_api/watchdog/#enable-the-watchdog","text":"1) Go to HW.h file and set the next 3 defines: WATCHDOG_ENABLE : WATCHDOG_TIMEOUT_MS : The max amount of time (milliseconds) that if the watchdog does not pet (reload) -> the watchdog will restart the MCU, WATCHDOG_PET_MS : The time between pet (reload). WATCHDOG_TASK_PRIORITY : The priority of the watchdog task the reload (pet) of the watchdog, should be the less prioritized task. Example: if we want that watchdog will reset the MCU if it does not pet more than 100ms, also we want that our watchdog service will pet the watchdog every 90ms, so the definition should be like this: #define WATCHDOG_ENABLE #define WATCHDOG_TIMEOUT_MS (100) #define WATCHDOG_PET_MS (90) #define WATCHDOG_TASK_PRIORITY (14) 2) Go to file TasksManager.cpp , in the function Tasks_manager_start() add the watchdog: #include \"Watchdog.h\" void Tasks_manager_start() { Watchdog::Instance()->StartTask();","title":"Enable the watchdog"},{"location":"Add_stm32_api/watchdog/#note","text":"The watchdog priority is should be the lowest that possible but you need to careful to not be in the same or low priority of the task that will take more time than define WATCHDOG_TIMEOUT_MS The watchdog must not enable when you want to debug your system and stop the run, the watchdog will kill you. When you set the system to sleep, you must somehow pet the watchdog because it works on the LSI clock and not on the main clock.","title":"note"},{"location":"How_to_use/introduction/","text":"Introduction The next page will help you to understand how to use create and use a thread and communicate between them, it also includes a simple example of the basic API like Mutex and Semaphore... My recommendation is to start with Task (Thread) page , this is the main page that explains how to create and use a task, the page is a little long but very simple, good luck :)","title":"Introduction"},{"location":"How_to_use/introduction/#introduction","text":"The next page will help you to understand how to use create and use a thread and communicate between them, it also includes a simple example of the basic API like Mutex and Semaphore... My recommendation is to start with Task (Thread) page , this is the main page that explains how to create and use a task, the page is a little long but very simple, good luck :)","title":"Introduction"},{"location":"How_to_use/memory_manager/","text":"Memory manager This package is optional. It gives you an easy way to init the ThreadX pool of bytes and override the new and the delete function Note: To do that you will need to change the ThreadX configuration to use \"dynamic allocation\", and you also need to config the \".ld\" file to allocate the ram section for the pool, steps 2 and 3, and 4 in this tutorial is for that but work only for STM32H743, if you have different MCU you will need to figure it out yourself how to do that (again you have a lot tutorial over the internet). 1) Go to HW.h file and add the define '#define MEMORY_MANAGER_ENABLE' you also need to define MEMORY_MANAGER_POOL_SIZE with the size of the memory pool, for example, if we want a pool of 64000 bytes, you will need to add the next lines to HW.h file: #define MEMORY_MANAGER_ENABLE #define MEMORY_MANAGER_POOL_SIZE (64000) 2) Go To file app_azure_rtos.c to function VOID tx_application_define(VOID *first_unused_memory) and move the function StartThreadXPlusPlus(first_unused_memory); to end of the function: 3) Now you need to config the ThreadX to work with dynamic allocation, Go to project explorer and double click on the XX.ioc file (XX is the name of your project), This will open the configuration window, and on the right side of the screen select the Middleware and Software Packs and then select X-CUBE-AZURES-H7 , it will open two screens, In the bottom screen ( Configuration ) select the tab AzureRTOS Application inside the tab open the list of Memory Configuration , and set the field Memory allocation to Use Dynamic Allocation then save the file, File->save 4) Now we need to allocate space in the RAM for the memory, you need to go to project explorer of your project and go to file STM32xxx_FLASH.ld (the xxx will be the name of your MCU model), you need to place a new block of ram that has the size of the memory pool and save the size into variable __RAM_segment_used_end__ , this block should be between the block of bss and _user_heap_check . For example, let's assume that we want to allocate 64000 bytes, then we need to add the next block: ._threadx_heap : { . = ALIGN(8); __RAM_segment_used_end__ = .; . = . + 64K; . = ALIGN(8); } >RAM_D1 and it should be between bss and _user_heap_check , so it look like that","title":"Memory manager"},{"location":"How_to_use/memory_manager/#memory-manager","text":"This package is optional. It gives you an easy way to init the ThreadX pool of bytes and override the new and the delete function Note: To do that you will need to change the ThreadX configuration to use \"dynamic allocation\", and you also need to config the \".ld\" file to allocate the ram section for the pool, steps 2 and 3, and 4 in this tutorial is for that but work only for STM32H743, if you have different MCU you will need to figure it out yourself how to do that (again you have a lot tutorial over the internet). 1) Go to HW.h file and add the define '#define MEMORY_MANAGER_ENABLE' you also need to define MEMORY_MANAGER_POOL_SIZE with the size of the memory pool, for example, if we want a pool of 64000 bytes, you will need to add the next lines to HW.h file: #define MEMORY_MANAGER_ENABLE #define MEMORY_MANAGER_POOL_SIZE (64000) 2) Go To file app_azure_rtos.c to function VOID tx_application_define(VOID *first_unused_memory) and move the function StartThreadXPlusPlus(first_unused_memory); to end of the function: 3) Now you need to config the ThreadX to work with dynamic allocation, Go to project explorer and double click on the XX.ioc file (XX is the name of your project), This will open the configuration window, and on the right side of the screen select the Middleware and Software Packs and then select X-CUBE-AZURES-H7 , it will open two screens, In the bottom screen ( Configuration ) select the tab AzureRTOS Application inside the tab open the list of Memory Configuration , and set the field Memory allocation to Use Dynamic Allocation then save the file, File->save 4) Now we need to allocate space in the RAM for the memory, you need to go to project explorer of your project and go to file STM32xxx_FLASH.ld (the xxx will be the name of your MCU model), you need to place a new block of ram that has the size of the memory pool and save the size into variable __RAM_segment_used_end__ , this block should be between the block of bss and _user_heap_check . For example, let's assume that we want to allocate 64000 bytes, then we need to add the next block: ._threadx_heap : { . = ALIGN(8); __RAM_segment_used_end__ = .; . = . + 64K; . = ALIGN(8); } >RAM_D1 and it should be between bss and _user_heap_check , so it look like that","title":"Memory manager"},{"location":"How_to_use/task/","text":"Task Introduction In ThreadX++ the thread are task , so when you create a task you create a thread of ThreadX, in this tutorial you will learn how to create and how to run code by task and send data between data and of course how to go to sleep. Every task is created with a queue of messages, the messages are used to invoke the task by event and send data between tasks. Create Task In this example, we will create LedTask that blinks the led every 1 second. e 1) Add the include #include \"Task.h\" 2) Create a class that inherits from a Task class: class LedTask : public Task 3) In the implementation of the constructor you will need to call to the constructor of the Task class and enter 3 parameters: name: The name of the task. priority: The priority of the task. stack size: The size of the stack of the task. num_message: The number of messages that the task will hold in the queue, the default argument value is 10. Example: We will create a task with priority 10 and stack size 1024 : LedTask::LedTask() : Task(\"LedTask\", 10, 1024) { } 4) Add the LedTask to TaskManager.cpp to function Tasks_manager_start() : void Tasks_manager_start() { printf(\"ThreadX++ start run \\n\"); LedTaskPointer->StartTask(); } Run code by task We have 4 ways to run code from the created task: 1. Polling: Function that have endless loop ( while(1){} ). 2. Get message: A message that sends by another thread can invoke the current thread to run a specific callback. 3. Event: An Event is an object that the task can register to it by callback when the event invokes -> every registered thread will run the callback. 4. Time event: This object invokes a callback of the task after a specific amount of time. Polling Every task has its own \"main loop\", which is a function that has an endless loop ( while(1){} ), in class Task you have an internal function that calls Main_loop() , this function run the endless loop: void Task::Main_loop() { while(1) { Sleep_ms(); } } If you want you can override this function by your class that inherited Task class, Important note: If you override, you must call to function Sleep_ms() , if you don't call it -> other thread can't send your thread messages, also all the events and time events will not invoke your task, the function Sleep_ms() can get parameter of timeout at milliseconds, so every time you want to sleep you can call this function with the time you want to sleep, you can see it in the next example: Example: in the next example the class ledTask will toggle the led every 500ms: void LedTask::Main_loop() { while(1) { ToggleLed(); Sleep_ms(500); } } Get message The message is the ability to send messages from one task to a second task, for example, let's assume that we have two tasks: LedTask and TestTask , we want that TestTask will send to a LedTask message every second, to perform it we will need to do two things: 1) The TestTask needs to call to member function bool NotifyMessage() of the LedTask every second, the function returns if the message gets into a queue of the messages of LedTask successfully, Example: void TestTask::Main_loop() { while(1) { LedTaskPointer->NotifyMessage(); Sleep_ms(1000); } } 2) The LedTask need to override the function void ReceiveMsg(void* pointer) , example: void LedTask::ReceiveMsg(void* pointer) { printf(\"Get message \\n\",); } The result of the code above is every second the LedTask will print \"Get message\" Important Point: Get different messages: If you get more than one type of message (for example: if you have led and you want that LedTask can get a message that turns on the led and a message that turns off the led) it can be a problem because you can't know with type of message you get, to solve that problem you will need to send data in this message and the LedTask need to know to parse the data, I will explain it in section Send data between tasks . Event An event is an object that the task can register to it by callback, when the event invokes -> every registered thread will run the callback, For the next example let's assume that we have 2 tasks: LedTask and TestTask , we want that TestTask has an event that LedTask can register to it and every second the TestTask will invoke the Event. To do that we need 4 steps: 1) Create the event object in TestTask: #include \"Event.h\" class TestTask : public Task { public: TestTask(); void Main_loop(); Event event; }; 2) Create a callback in the LedTask: class LedTask : public Task { public: LedTask(); void Main_loop(); void Callback(void* param) { printf(\"Event invoke \\n\"); } }; Note: You can change the name of the callback as you like but it must be in the next pattern void <Function name>(void* pointer) 3) Register the LedTask to the event of TestTask: void LedTask::Main_loop() { TestTaskPointer->event.Register(&LedTask::Callback, this, this); while(1) Sleep_ms(); } Parameter explain: The register function of the event gets 3 parameters: Function: Pointer to function. Class pointer: Pointer to the class that has the callback (in my example is a pointer to LedTask) Task pointer: Pointer to the class that is inherited from the task class (in my example is a pointer to LedTask) 4) Invoke the event every second: void TestTask::Main_loop() { while(1) { event.Invoke(); Sleep_ms(1000); } } The result of the code is every second the LedTask will print \"Event invoke\" Time event This object invokes a callback of a task after a specific amount of time, For the next example let's assume that we had one task: LedTask and we want to toggle the led every 100ms, to do that we need to perform 2 steps: 1) Create callback: void LedTask::Callback(void* param) { printf(\"Toggle led \\n\") } Note: You can change the name of the callback as you like but it must be in the next pattern void <Function name>(void* pointer) 2) Create the event: #include \"TimeEvent.h\" void LedTask::Main_loop() { TimeEvent time_event(&LedTask::Callback, this, this, 100, true) while(1) Sleep_ms(); } Parameter explain: The register function of the time event gets 5 parameters: Function: Pointer to function. Class pointer: Pointer to the class that has the callback (in my example is a pointer to LedTask) Task pointer: Pointer to the class that is inherited from task class (in my example is a pointer to LedTask) Time to execute: The number of milliseconds until the call to callback. Is periodic: Boolean, false - The callback call once, true - call periodic (forever). Send data between tasks To send data between tasks you have 2 ways: 1. Message: Send message from one task to other. 2. Event: Create an event that every task that gets registered by callback, when invoking the event you can also add data and every callback will get the data. As you can see both methods are also used to run the code by another task. Here the example of how to implement them: Send data by message Send messages from one task to other. For example, let's assume that we have two tasks: LedTask and TestTask , we want that TestTask will send to a LedTask message every second, the message will include a counter and the LedTask will print it to perform it we will need to do two things: 1) The TestTask need to call to member function bool NotifyMessage(void* pointer) of the LedTask every second, the function returns if the message gets into the queue of the message of LedTask successfully, Example: void TestTask::Main_loop() { int counter = 0; while(1) { LedTaskPointer->NotifyMessage((void*)&counter); Sleep_ms(1000); counter++; } } 2) The LedTask need to override the function void ReceiveMsg(void* pointer) , example: void LedTask::ReceiveMsg(void* pointer) { printf(\"Counter %d \\n\", *(int*)param); } The result of the code above is: every second the LedTask will print \"Counter X\" where X is the counter. Send data by event Create an event that every task that gets registered by callback, when invoking the event you can also add data and every callback will get the data. For the next example let's assume that we have 2 tasks: LedTask and TestTask , we want that TestTask has an event that LedTask can register to it and every second the TestTask will invoke the Event, and also send a counter over the event. To do that we need 4 steps: 1) Create the event object in TestTask: #include \"Event.h\" class TestTask : public Task { public: TestTask(); void Main_loop(); Event event; }; 2) Create a callback in the LedTask: class LedTask : public Task { public: LedTask(); void Main_loop(); void Callback(void* param) { printf(\"Counter %d \\n\", *(int*)param); } }; Note: You can change the name of the callback as you like but it must be in the next pattern void <Function name>(void* pointer) 3) Register the LedTask to an event of TestTask: void LedTask::Main_loop() { TestTaskPointer->event.Register(&LedTask::Callback, this, this); while(1) Sleep_ms(); } Parameter explain: The register function of the event gets 3 parameters: Function: Pointer to function. Class pointer: Pointer to the class that has the callback (in my example is a pointer to LedTask) Task pointer: Pointer to the class that is inherited from task class (in my example is a pointer to LedTask) 4) Invoke the event every second and send the value of the counter: void TestTask::Main_loop() { int counter = 0; while(1) { event.Invoke((void*)&counter); Sleep_ms(1000); counter++; } } The result of the code is every second the LedTask will print \"Counter X\" where X is the counter Sleep (Suspend) Most of the time we want that the task will be suspended so the others task can run, in ThreadX++ you have serval ways to set the task to sleep. 1. Sleep function: Call the function Sleep_ms of class Task. 2. Wait for a message: When you wait for a new message to arrive the task is sleep. 3. ThreadX API: mutex, semaphore, queue. Sleep function Call the function Sleep_ms of class Task. void LedTask::Main_loop() { while(1) { Sleep_ms(1000); Sleep_ms(QUEUE_NO_WAIT); } } Because we override the Main_loop() function we must call to function Sleep_ms() , if we do not call it -> we don't get any message from the other task and the event will not invoke the callback of this task. Wait for a message When you wait for a new message to arrive the task is sleep. void LedTask::Main_loop() { while(1) { Sleep_ms(); } } When we call to function Sleep_ms() the task will sleep until it gets a message or invoke by an event, the function also can get the parameter of timeout in milliseconds and when the timeout occurs the task will resume. ThreadX API When using the API locking mechanism of ThreadX the task will go to sleep: Mutex: If we have two task, task1 lock the mutex, than the task2 try to lock, the task2 will sleep until the task1 will unlock the mutex. Semaphore: When we have two task, task1 Put the semaphore, the task1 will sleep until the task2 Get the semaphore. Queue When pull from a queue the task goes to sleep Singleton Singleton is a design pattern, if you don't know what is, you can look here . This not really part of the task but in my opinion it very helpful because for most of the tasks if not all of them you will be want to be only single of them and have easy access from everywhere, So I create a class Singleton that can be inherited: How to create In the class that you want to inherit you need to do 3 things: 1. Add #include \"Singleton.h\" . 2. Inheriting from singleton class: class <class name> : public Singleton<class name> . 3. In the class definition add friend Singleton<class name> Example: If you want to create task LedTask and you want him to be a singleton, the declaration of the class looks like that: #include \"Task.h\" #include \"Singleton.h\" class LedTask : public Task, public Singleton<LedTask> { friend Singleton<LedTask>; private: LedTask(); void ToggleLed(); static const uint16_t TASK_PRIORITY = NORMAL_PRIORITY; static const uint16_t STACK_SIZE = 1024; protected: virtual void ReceiveMsg(void* pointer); }; How to use When you want to call to a class that is also singleton you need to do only 2 steps: 1. Add the include of the class. 2. Call to class like that <class name>::Instance-><someFunction> . Example: If we want to call to function NotifyMessage() of the task LedTask : #include \"LedTask.h\" void Some_function() { LedTask::Instance()->NotifyMessage(); } Note: You can use the singleton on any class (and not only the tasks).","title":"Task (Thread)"},{"location":"How_to_use/task/#task","text":"","title":"Task"},{"location":"How_to_use/task/#introduction","text":"In ThreadX++ the thread are task , so when you create a task you create a thread of ThreadX, in this tutorial you will learn how to create and how to run code by task and send data between data and of course how to go to sleep. Every task is created with a queue of messages, the messages are used to invoke the task by event and send data between tasks.","title":"Introduction"},{"location":"How_to_use/task/#create-task","text":"In this example, we will create LedTask that blinks the led every 1 second. e 1) Add the include #include \"Task.h\" 2) Create a class that inherits from a Task class: class LedTask : public Task 3) In the implementation of the constructor you will need to call to the constructor of the Task class and enter 3 parameters: name: The name of the task. priority: The priority of the task. stack size: The size of the stack of the task. num_message: The number of messages that the task will hold in the queue, the default argument value is 10. Example: We will create a task with priority 10 and stack size 1024 : LedTask::LedTask() : Task(\"LedTask\", 10, 1024) { } 4) Add the LedTask to TaskManager.cpp to function Tasks_manager_start() : void Tasks_manager_start() { printf(\"ThreadX++ start run \\n\"); LedTaskPointer->StartTask(); }","title":"Create Task"},{"location":"How_to_use/task/#run-code-by-task","text":"We have 4 ways to run code from the created task: 1. Polling: Function that have endless loop ( while(1){} ). 2. Get message: A message that sends by another thread can invoke the current thread to run a specific callback. 3. Event: An Event is an object that the task can register to it by callback when the event invokes -> every registered thread will run the callback. 4. Time event: This object invokes a callback of the task after a specific amount of time.","title":"Run code by task"},{"location":"How_to_use/task/#polling","text":"Every task has its own \"main loop\", which is a function that has an endless loop ( while(1){} ), in class Task you have an internal function that calls Main_loop() , this function run the endless loop: void Task::Main_loop() { while(1) { Sleep_ms(); } } If you want you can override this function by your class that inherited Task class, Important note: If you override, you must call to function Sleep_ms() , if you don't call it -> other thread can't send your thread messages, also all the events and time events will not invoke your task, the function Sleep_ms() can get parameter of timeout at milliseconds, so every time you want to sleep you can call this function with the time you want to sleep, you can see it in the next example: Example: in the next example the class ledTask will toggle the led every 500ms: void LedTask::Main_loop() { while(1) { ToggleLed(); Sleep_ms(500); } }","title":"Polling"},{"location":"How_to_use/task/#get-message","text":"The message is the ability to send messages from one task to a second task, for example, let's assume that we have two tasks: LedTask and TestTask , we want that TestTask will send to a LedTask message every second, to perform it we will need to do two things: 1) The TestTask needs to call to member function bool NotifyMessage() of the LedTask every second, the function returns if the message gets into a queue of the messages of LedTask successfully, Example: void TestTask::Main_loop() { while(1) { LedTaskPointer->NotifyMessage(); Sleep_ms(1000); } } 2) The LedTask need to override the function void ReceiveMsg(void* pointer) , example: void LedTask::ReceiveMsg(void* pointer) { printf(\"Get message \\n\",); } The result of the code above is every second the LedTask will print \"Get message\" Important Point: Get different messages: If you get more than one type of message (for example: if you have led and you want that LedTask can get a message that turns on the led and a message that turns off the led) it can be a problem because you can't know with type of message you get, to solve that problem you will need to send data in this message and the LedTask need to know to parse the data, I will explain it in section Send data between tasks .","title":"Get message"},{"location":"How_to_use/task/#event","text":"An event is an object that the task can register to it by callback, when the event invokes -> every registered thread will run the callback, For the next example let's assume that we have 2 tasks: LedTask and TestTask , we want that TestTask has an event that LedTask can register to it and every second the TestTask will invoke the Event. To do that we need 4 steps: 1) Create the event object in TestTask: #include \"Event.h\" class TestTask : public Task { public: TestTask(); void Main_loop(); Event event; }; 2) Create a callback in the LedTask: class LedTask : public Task { public: LedTask(); void Main_loop(); void Callback(void* param) { printf(\"Event invoke \\n\"); } }; Note: You can change the name of the callback as you like but it must be in the next pattern void <Function name>(void* pointer) 3) Register the LedTask to the event of TestTask: void LedTask::Main_loop() { TestTaskPointer->event.Register(&LedTask::Callback, this, this); while(1) Sleep_ms(); } Parameter explain: The register function of the event gets 3 parameters: Function: Pointer to function. Class pointer: Pointer to the class that has the callback (in my example is a pointer to LedTask) Task pointer: Pointer to the class that is inherited from the task class (in my example is a pointer to LedTask) 4) Invoke the event every second: void TestTask::Main_loop() { while(1) { event.Invoke(); Sleep_ms(1000); } } The result of the code is every second the LedTask will print \"Event invoke\"","title":"Event"},{"location":"How_to_use/task/#time-event","text":"This object invokes a callback of a task after a specific amount of time, For the next example let's assume that we had one task: LedTask and we want to toggle the led every 100ms, to do that we need to perform 2 steps: 1) Create callback: void LedTask::Callback(void* param) { printf(\"Toggle led \\n\") } Note: You can change the name of the callback as you like but it must be in the next pattern void <Function name>(void* pointer) 2) Create the event: #include \"TimeEvent.h\" void LedTask::Main_loop() { TimeEvent time_event(&LedTask::Callback, this, this, 100, true) while(1) Sleep_ms(); } Parameter explain: The register function of the time event gets 5 parameters: Function: Pointer to function. Class pointer: Pointer to the class that has the callback (in my example is a pointer to LedTask) Task pointer: Pointer to the class that is inherited from task class (in my example is a pointer to LedTask) Time to execute: The number of milliseconds until the call to callback. Is periodic: Boolean, false - The callback call once, true - call periodic (forever).","title":"Time event"},{"location":"How_to_use/task/#send-data-between-tasks","text":"To send data between tasks you have 2 ways: 1. Message: Send message from one task to other. 2. Event: Create an event that every task that gets registered by callback, when invoking the event you can also add data and every callback will get the data. As you can see both methods are also used to run the code by another task. Here the example of how to implement them:","title":"Send data between tasks"},{"location":"How_to_use/task/#send-data-by-message","text":"Send messages from one task to other. For example, let's assume that we have two tasks: LedTask and TestTask , we want that TestTask will send to a LedTask message every second, the message will include a counter and the LedTask will print it to perform it we will need to do two things: 1) The TestTask need to call to member function bool NotifyMessage(void* pointer) of the LedTask every second, the function returns if the message gets into the queue of the message of LedTask successfully, Example: void TestTask::Main_loop() { int counter = 0; while(1) { LedTaskPointer->NotifyMessage((void*)&counter); Sleep_ms(1000); counter++; } } 2) The LedTask need to override the function void ReceiveMsg(void* pointer) , example: void LedTask::ReceiveMsg(void* pointer) { printf(\"Counter %d \\n\", *(int*)param); } The result of the code above is: every second the LedTask will print \"Counter X\" where X is the counter.","title":"Send data by message"},{"location":"How_to_use/task/#send-data-by-event","text":"Create an event that every task that gets registered by callback, when invoking the event you can also add data and every callback will get the data. For the next example let's assume that we have 2 tasks: LedTask and TestTask , we want that TestTask has an event that LedTask can register to it and every second the TestTask will invoke the Event, and also send a counter over the event. To do that we need 4 steps: 1) Create the event object in TestTask: #include \"Event.h\" class TestTask : public Task { public: TestTask(); void Main_loop(); Event event; }; 2) Create a callback in the LedTask: class LedTask : public Task { public: LedTask(); void Main_loop(); void Callback(void* param) { printf(\"Counter %d \\n\", *(int*)param); } }; Note: You can change the name of the callback as you like but it must be in the next pattern void <Function name>(void* pointer) 3) Register the LedTask to an event of TestTask: void LedTask::Main_loop() { TestTaskPointer->event.Register(&LedTask::Callback, this, this); while(1) Sleep_ms(); } Parameter explain: The register function of the event gets 3 parameters: Function: Pointer to function. Class pointer: Pointer to the class that has the callback (in my example is a pointer to LedTask) Task pointer: Pointer to the class that is inherited from task class (in my example is a pointer to LedTask) 4) Invoke the event every second and send the value of the counter: void TestTask::Main_loop() { int counter = 0; while(1) { event.Invoke((void*)&counter); Sleep_ms(1000); counter++; } } The result of the code is every second the LedTask will print \"Counter X\" where X is the counter","title":"Send data by event"},{"location":"How_to_use/task/#sleep-suspend","text":"Most of the time we want that the task will be suspended so the others task can run, in ThreadX++ you have serval ways to set the task to sleep. 1. Sleep function: Call the function Sleep_ms of class Task. 2. Wait for a message: When you wait for a new message to arrive the task is sleep. 3. ThreadX API: mutex, semaphore, queue.","title":"Sleep (Suspend)"},{"location":"How_to_use/task/#sleep-function","text":"Call the function Sleep_ms of class Task. void LedTask::Main_loop() { while(1) { Sleep_ms(1000); Sleep_ms(QUEUE_NO_WAIT); } } Because we override the Main_loop() function we must call to function Sleep_ms() , if we do not call it -> we don't get any message from the other task and the event will not invoke the callback of this task.","title":"Sleep function"},{"location":"How_to_use/task/#wait-for-a-message","text":"When you wait for a new message to arrive the task is sleep. void LedTask::Main_loop() { while(1) { Sleep_ms(); } } When we call to function Sleep_ms() the task will sleep until it gets a message or invoke by an event, the function also can get the parameter of timeout in milliseconds and when the timeout occurs the task will resume.","title":"Wait for a message"},{"location":"How_to_use/task/#threadx-api","text":"When using the API locking mechanism of ThreadX the task will go to sleep: Mutex: If we have two task, task1 lock the mutex, than the task2 try to lock, the task2 will sleep until the task1 will unlock the mutex. Semaphore: When we have two task, task1 Put the semaphore, the task1 will sleep until the task2 Get the semaphore. Queue When pull from a queue the task goes to sleep","title":"ThreadX API"},{"location":"How_to_use/task/#singleton","text":"Singleton is a design pattern, if you don't know what is, you can look here . This not really part of the task but in my opinion it very helpful because for most of the tasks if not all of them you will be want to be only single of them and have easy access from everywhere, So I create a class Singleton that can be inherited:","title":"Singleton"},{"location":"How_to_use/task/#how-to-create","text":"In the class that you want to inherit you need to do 3 things: 1. Add #include \"Singleton.h\" . 2. Inheriting from singleton class: class <class name> : public Singleton<class name> . 3. In the class definition add friend Singleton<class name> Example: If you want to create task LedTask and you want him to be a singleton, the declaration of the class looks like that: #include \"Task.h\" #include \"Singleton.h\" class LedTask : public Task, public Singleton<LedTask> { friend Singleton<LedTask>; private: LedTask(); void ToggleLed(); static const uint16_t TASK_PRIORITY = NORMAL_PRIORITY; static const uint16_t STACK_SIZE = 1024; protected: virtual void ReceiveMsg(void* pointer); };","title":"How to create"},{"location":"How_to_use/task/#how-to-use","text":"When you want to call to a class that is also singleton you need to do only 2 steps: 1. Add the include of the class. 2. Call to class like that <class name>::Instance-><someFunction> . Example: If we want to call to function NotifyMessage() of the task LedTask : #include \"LedTask.h\" void Some_function() { LedTask::Instance()->NotifyMessage(); } Note: You can use the singleton on any class (and not only the tasks).","title":"How to use"},{"location":"How_to_use/threadx_api/","text":"ThreadX API In this section you get explain how to create and use the Mutex, Semaphore, Queue. Mutex Create #include \"Mutex.h\" Mutex my_mutex; How to use The mutex have two function: Lock , Unlock Lock bool Lock(uint32_t timeout_MS = TX_WAIT_FOREVER); Timeout: Timeout in milliseconds, If the mutex is already lock the task will wait until the mutex unlock or timeout occur, if you want to wait forever you can use define MUTEX_WAIT_FOREVER, if you want to not wait at all you can use define MUTEX_NO_WAIT Return value: Boolean, True - lock success (not timeout). In next example, we lock and wait forever. my_mutex.Lock(); In the next example we will set timeout of 100ms: my_mutex.Lock(100); Unlock: void Unlock(); The unlock you just need to call to unlock function: my_mutex.Unlock(); Semaphore Create #include \"Semaphore.h\" Semaphore my_semaphore; The default value of the \"initial count\" is 0, if you want to change it you can send the number you like to Ctor of the semaphore, in next example the semaphore set the \"initial count\" to 5: #include \"Semaphore.h\" Semaphore my_semaphore(5); How to use The semaphore have only two function: Get , Put , Get bool Get(uint32_t timeout_MS = SEMAPHORE_WAIT_FOREVER); Timeout: Timeout in milliseconds, The get function can call without parameter and wait until other task will \"Put\" the semaphore or timeout occur, if you want to wait forever you can use define SEMAPHORE_WAIT_FOREVER, if you want to not wait at all you can use define SEMAPHORE_NO_WAIT Return value: Boolean, True - Get success (not timeout). In the next example we call Get() function and wait forever: my_semaphore.Get(); in next example the timeout is 200ms my_semaphore.Get(200); Put void Put(); To Put the semaphore you need to call to function Put() : my_semaphore.Put(); Queue Create My implementation of the queue is \"template\" so when you create the queue you need to choose what type of values you want the queue will hold, in the next explain the queue will hold int types that can hold 10 int values: #include \"Queue.h\" Queue<int> my_queue(10); If this was not clear: the queue Ctor get one parameter that set the number of the values that hold in the queue. How to use The queue have 2 functions: Push , Pull Push bool Push(T& value, uint32_t timeout_MS = QUEUE_NO_WAIT) Value: The value you want to push to queue, the parameter is reference. Timeout: Timeout in milliseconds, if the queue is full the task will wait until it can push the value, if you want to wait forever you can use define QUEUE_WAIT_FOREVER, if you want to not wait at all you can use define QUEUE_NO_WAIT Return value: Boolean, True - push success. In the next example we push \"int\" without waiting to timeout. int val = 5; my_queue.Push(val); In the next example we push \"int\" with timeout of 50ms. int val = 5; my_queue.Push(val, 50); Pull bool Pull(T& value, uint32_t timeout_MS = 10) Value: The value you want to pull from queue, the parameter is reference. Timeout: Timeout in milliseconds, if the queue is empty the task will wait until it can pull the value, if you want to wait forever you can use define QUEUE_WAIT_FOREVER, if you want to not wait at all you can use define QUEUE_NO_WAIT Return value: Boolean, True - pull success. In the next example we pull from queue without timeout int val; my_queue.Pull(val, TX_NO_WAIT);","title":"ThreadX API (Mutex, Semaphore, Queue)"},{"location":"How_to_use/threadx_api/#threadx-api","text":"In this section you get explain how to create and use the Mutex, Semaphore, Queue.","title":"ThreadX API"},{"location":"How_to_use/threadx_api/#mutex","text":"","title":"Mutex"},{"location":"How_to_use/threadx_api/#create","text":"#include \"Mutex.h\" Mutex my_mutex;","title":"Create"},{"location":"How_to_use/threadx_api/#how-to-use","text":"The mutex have two function: Lock , Unlock","title":"How to use"},{"location":"How_to_use/threadx_api/#lock","text":"bool Lock(uint32_t timeout_MS = TX_WAIT_FOREVER); Timeout: Timeout in milliseconds, If the mutex is already lock the task will wait until the mutex unlock or timeout occur, if you want to wait forever you can use define MUTEX_WAIT_FOREVER, if you want to not wait at all you can use define MUTEX_NO_WAIT Return value: Boolean, True - lock success (not timeout). In next example, we lock and wait forever. my_mutex.Lock(); In the next example we will set timeout of 100ms: my_mutex.Lock(100);","title":"Lock"},{"location":"How_to_use/threadx_api/#unlock","text":"void Unlock(); The unlock you just need to call to unlock function: my_mutex.Unlock();","title":"Unlock:"},{"location":"How_to_use/threadx_api/#semaphore","text":"","title":"Semaphore"},{"location":"How_to_use/threadx_api/#create_1","text":"#include \"Semaphore.h\" Semaphore my_semaphore; The default value of the \"initial count\" is 0, if you want to change it you can send the number you like to Ctor of the semaphore, in next example the semaphore set the \"initial count\" to 5: #include \"Semaphore.h\" Semaphore my_semaphore(5);","title":"Create"},{"location":"How_to_use/threadx_api/#how-to-use_1","text":"The semaphore have only two function: Get , Put ,","title":"How to use"},{"location":"How_to_use/threadx_api/#get","text":"bool Get(uint32_t timeout_MS = SEMAPHORE_WAIT_FOREVER); Timeout: Timeout in milliseconds, The get function can call without parameter and wait until other task will \"Put\" the semaphore or timeout occur, if you want to wait forever you can use define SEMAPHORE_WAIT_FOREVER, if you want to not wait at all you can use define SEMAPHORE_NO_WAIT Return value: Boolean, True - Get success (not timeout). In the next example we call Get() function and wait forever: my_semaphore.Get(); in next example the timeout is 200ms my_semaphore.Get(200);","title":"Get"},{"location":"How_to_use/threadx_api/#put","text":"void Put(); To Put the semaphore you need to call to function Put() : my_semaphore.Put();","title":"Put"},{"location":"How_to_use/threadx_api/#queue","text":"","title":"Queue"},{"location":"How_to_use/threadx_api/#create_2","text":"My implementation of the queue is \"template\" so when you create the queue you need to choose what type of values you want the queue will hold, in the next explain the queue will hold int types that can hold 10 int values: #include \"Queue.h\" Queue<int> my_queue(10); If this was not clear: the queue Ctor get one parameter that set the number of the values that hold in the queue.","title":"Create"},{"location":"How_to_use/threadx_api/#how-to-use_2","text":"The queue have 2 functions: Push , Pull","title":"How to use"},{"location":"How_to_use/threadx_api/#push","text":"bool Push(T& value, uint32_t timeout_MS = QUEUE_NO_WAIT) Value: The value you want to push to queue, the parameter is reference. Timeout: Timeout in milliseconds, if the queue is full the task will wait until it can push the value, if you want to wait forever you can use define QUEUE_WAIT_FOREVER, if you want to not wait at all you can use define QUEUE_NO_WAIT Return value: Boolean, True - push success. In the next example we push \"int\" without waiting to timeout. int val = 5; my_queue.Push(val); In the next example we push \"int\" with timeout of 50ms. int val = 5; my_queue.Push(val, 50);","title":"Push"},{"location":"How_to_use/threadx_api/#pull","text":"bool Pull(T& value, uint32_t timeout_MS = 10) Value: The value you want to pull from queue, the parameter is reference. Timeout: Timeout in milliseconds, if the queue is empty the task will wait until it can pull the value, if you want to wait forever you can use define QUEUE_WAIT_FOREVER, if you want to not wait at all you can use define QUEUE_NO_WAIT Return value: Boolean, True - pull success. In the next example we pull from queue without timeout int val; my_queue.Pull(val, TX_NO_WAIT);","title":"Pull"},{"location":"Install/add_threadx_plus_plus/","text":"Add ThreadX++ Introduction In this tutorial we add the ThreadX++ to project Add ThreadX++ Clone the ThreadX++ Link Copy the folder ThreadX++ to your project. Now we need to add ThreadX++ to include path and source path (this step is explain in CUBE IDE, if you work on other IDE you need to figure this step yourself... good luck), In CUBE IDE go to Project->Properties , new window will open, in the left side of the window go to C/C++ Build->Settings , select tab Tool Settings , go to MCU G++ Compiler->Include paths , in the window you will see list of the included path, Add the path to ThreadX++/inc folder, you also need to add the inc folder at MCU G++ Compiler->Include paths . Now return to left side of the window and select C/C++ General->Paths and Symbols than select tab Source Location and add the folder ThreadX++/src In this step we call the function that add the ThreadX++ to system, Go to file AZURE_RTOS/Ap/app_azure_rtos.c and add the include #include <StartThreadX++.h\\> than add the call of the function StartThreadXPlusPlus(first_unused_memory); after the call of function App_ThreadX_Init Next step The next step is to learn the tutorials in section how to use , start with the Introduction","title":"Add ThreadX++"},{"location":"Install/add_threadx_plus_plus/#add-threadx","text":"","title":"Add ThreadX++"},{"location":"Install/add_threadx_plus_plus/#introduction","text":"In this tutorial we add the ThreadX++ to project","title":"Introduction"},{"location":"Install/add_threadx_plus_plus/#add-threadx_1","text":"Clone the ThreadX++ Link Copy the folder ThreadX++ to your project. Now we need to add ThreadX++ to include path and source path (this step is explain in CUBE IDE, if you work on other IDE you need to figure this step yourself... good luck), In CUBE IDE go to Project->Properties , new window will open, in the left side of the window go to C/C++ Build->Settings , select tab Tool Settings , go to MCU G++ Compiler->Include paths , in the window you will see list of the included path, Add the path to ThreadX++/inc folder, you also need to add the inc folder at MCU G++ Compiler->Include paths . Now return to left side of the window and select C/C++ General->Paths and Symbols than select tab Source Location and add the folder ThreadX++/src In this step we call the function that add the ThreadX++ to system, Go to file AZURE_RTOS/Ap/app_azure_rtos.c and add the include #include <StartThreadX++.h\\> than add the call of the function StartThreadXPlusPlus(first_unused_memory); after the call of function App_ThreadX_Init","title":"Add ThreadX++"},{"location":"Install/add_threadx_plus_plus/#next-step","text":"The next step is to learn the tutorials in section how to use , start with the Introduction","title":"Next step"},{"location":"Install/install_st/","text":"Install ThreadX on ST Introduction In this tutorial we will install ThreadX by using the CUBE IDE, first you need to install CUBE IDE than open project, after that you can install the ThreadX. I write tutorial but you not must to use them, you can find a lot of tutorials in google, just keep in mind that the ThreadX need to config to use static memory allocation (i add option to use also the dynamic memory allocation here ) Install CUBE IDE You can download the CUBE IDE from here: Link You also need to download CUBE MX: Link Open project Open Cube IDE Go to File->New->STM32 project New window will open, in field Commercial Part Number you need to add your STM32 model (\"for example my is STM32H743ZIT6\"), in the right bottom of the screen you will see list of STM32 modules, select your model from the list, on bottom of screen press on the Next > New window will open, in the field Targeted Language select C++ , and in the field Project Name: Write the name of the your project, press on the Finish button. New window Eil ask if you want memory Protection, use your brain and press Yes . Now wait, it can take sometimes, in the end you will get the next screen Add ThreadX In the screen you need to select the tab Pinout & configuration and select Software Packs , than select Manage software packs New window will open, select tab STMicroelectronics , in this tab you need to find X-CUBE-AZRTOS-XX (\"XX\" is the name of your family model, for example my is \"H7\"), than select it and it open list of package, you need to check the Azure RTOS STM32Cube expansion package for STM32XX series (again \"XX\" is the name of your family model), than press install After the download finish, Now you need to return to main screen and again select the tab Pinout & configuration and select Software Packs , but now select the Select Components New window will open, you will see list of all the pack you and add to your project, you need to select STMicroelectronics.X-CUBE-AZRTOS-XX (again \"XX\" is the name of your family model) -> RTOS ThreadX-> ThreadX , than select the checkbox of Core , Note: If STMicroelectronics.X-CUBE-AZRTOS-XX is gray press on install, after the install select it. On the main screen on the left side you see list of option, select Middleware and Software Packs , it open a list, than select X-CUBE-AZRTOS-XX , it open new screen, check the box of field RTOS ThreadX , Save the file (go to File->Save ), the IDE will generate the code, the first time will take sometime. Next step Now you ready to start with the real thing! Add ThreadX++ .","title":"Install ThreadX on ST"},{"location":"Install/install_st/#install-threadx-on-st","text":"","title":"Install ThreadX on ST"},{"location":"Install/install_st/#introduction","text":"In this tutorial we will install ThreadX by using the CUBE IDE, first you need to install CUBE IDE than open project, after that you can install the ThreadX. I write tutorial but you not must to use them, you can find a lot of tutorials in google, just keep in mind that the ThreadX need to config to use static memory allocation (i add option to use also the dynamic memory allocation here )","title":"Introduction"},{"location":"Install/install_st/#install-cube-ide","text":"You can download the CUBE IDE from here: Link You also need to download CUBE MX: Link","title":"Install CUBE IDE"},{"location":"Install/install_st/#open-project","text":"Open Cube IDE Go to File->New->STM32 project New window will open, in field Commercial Part Number you need to add your STM32 model (\"for example my is STM32H743ZIT6\"), in the right bottom of the screen you will see list of STM32 modules, select your model from the list, on bottom of screen press on the Next > New window will open, in the field Targeted Language select C++ , and in the field Project Name: Write the name of the your project, press on the Finish button. New window Eil ask if you want memory Protection, use your brain and press Yes . Now wait, it can take sometimes, in the end you will get the next screen","title":"Open project"},{"location":"Install/install_st/#add-threadx","text":"In the screen you need to select the tab Pinout & configuration and select Software Packs , than select Manage software packs New window will open, select tab STMicroelectronics , in this tab you need to find X-CUBE-AZRTOS-XX (\"XX\" is the name of your family model, for example my is \"H7\"), than select it and it open list of package, you need to check the Azure RTOS STM32Cube expansion package for STM32XX series (again \"XX\" is the name of your family model), than press install After the download finish, Now you need to return to main screen and again select the tab Pinout & configuration and select Software Packs , but now select the Select Components New window will open, you will see list of all the pack you and add to your project, you need to select STMicroelectronics.X-CUBE-AZRTOS-XX (again \"XX\" is the name of your family model) -> RTOS ThreadX-> ThreadX , than select the checkbox of Core , Note: If STMicroelectronics.X-CUBE-AZRTOS-XX is gray press on install, after the install select it. On the main screen on the left side you see list of option, select Middleware and Software Packs , it open a list, than select X-CUBE-AZRTOS-XX , it open new screen, check the box of field RTOS ThreadX , Save the file (go to File->Save ), the IDE will generate the code, the first time will take sometime.","title":"Add ThreadX"},{"location":"Install/install_st/#next-step","text":"Now you ready to start with the real thing! Add ThreadX++ .","title":"Next step"}]}