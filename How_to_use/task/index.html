<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../../img/favicon.ico" />
    <title>Task (Thread) - ThreadX++</title>
    <link rel="stylesheet" href="../../css/theme.css" />
    <link rel="stylesheet" href="../../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "Task (Thread)";
        var mkdocs_page_input_path = "How_to_use\\task.md";
        var mkdocs_page_url = null;
      </script>
    
    <script src="../../js/jquery-3.6.0.min.js" defer></script>
    <!--[if lt IE 9]>
      <script src="../../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
      <script>hljs.initHighlightingOnLoad();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../.." class="icon icon-home"> ThreadX++
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../..">Home</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">Install</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../Install/install_st/">Install ThreadX on ST</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../Install/add_threadx_plus_plus/">Add ThreadX++</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">How to use</span></p>
              <ul class="current">
                  <li class="toctree-l1"><a class="reference internal" href="../introduction/">Introduction</a>
                  </li>
                  <li class="toctree-l1 current"><a class="reference internal current" href="./">Task (Thread)</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#introduction">Introduction</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#create-task">Create Task</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#run-code-by-task">Run code by task</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#polling">Polling</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#get-message">Get message</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#event">Event</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#time-event">Time event</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#send-data-between-tasks">Send data between tasks</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#send-data-by-message">Send data by message</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#send-data-by-event">Send data by event</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#sleep-suspend">Sleep (Suspend)</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#sleep-function">Sleep function</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#wait-for-a-message">Wait for a message</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#threadx-api">ThreadX API</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#singleton">Singleton</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#how-to-create">How to create</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#how-to-use">How to use</a>
    </li>
        </ul>
    </li>
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../threadx_api/">ThreadX API (Mutex, Semaphore, Queue)</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../memory_manager/">Memory manager</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Add STM32 API</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../Add_stm32_api/config_printf/">Config printf</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../Add_stm32_api/watchdog/">Watchdog</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../Add_stm32_api/registry/">Registry</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../Add_stm32_api/measure_time/">Measure time</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">About</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../about/">About</a>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../..">ThreadX++</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../.." class="icon icon-home" alt="Docs"></a> &raquo;</li>
          <li>How to use &raquo;</li>
      <li>Task (Thread)</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="task">Task</h1>
<h2 id="introduction">Introduction</h2>
<p>In ThreadX++ the <code>thread</code> are <code>task</code>, so when you create a task you create a thread of ThreadX, in this tutorial you will learn how to create and how to run code by task and send data between data and of course how to go to sleep.<br />
Every task is created with a queue of messages, the messages are used to invoke the task by event and send data between tasks.</p>
<h2 id="create-task">Create Task</h2>
<p>In this example, we will create LedTask that blinks the led every 1 second.
e
<strong>1)</strong> Add the include </p>
<pre><code>#include &quot;Task.h&quot;
</code></pre>
<p><strong>2)</strong> Create a class that inherits from a Task class:</p>
<pre><code class="language-e">class LedTask : public Task
</code></pre>
<p><strong>3)</strong> In the implementation of the constructor you will need to call to the constructor of the Task class and enter 3 parameters:<br />
<strong>name:</strong> The name of the task.<br />
<strong>priority:</strong> The priority of the task.<br />
<strong>stack size:</strong> The size of the stack of the task.<br />
<strong>num_message:</strong> The number of messages that the task will hold in the queue, the default argument value is 10.</p>
<p><strong>Example:</strong> We will create a task with priority <code>10</code> and stack size <code>1024</code>:</p>
<pre><code>LedTask::LedTask() : Task(&quot;LedTask&quot;, 10, 1024) { }
</code></pre>
<p><strong>4)</strong> Add the LedTask to <code>TaskManager.cpp</code> to function <code>Tasks_manager_start()</code>:</p>
<pre><code>void Tasks_manager_start()
{
    printf(&quot;ThreadX++ start run \n&quot;);

    LedTaskPointer-&gt;StartTask();
}
</code></pre>
<h2 id="run-code-by-task">Run code by task</h2>
<p>We have 4 ways to run code from the created task:<br />
1. <a href="#polling">Polling:</a> Function that have endless loop (<code>while(1){}</code>).<br />
2. <a href="#get-message">Get message:</a> A message that sends by another thread can invoke the current thread to run a specific callback.<br />
3. <a href="#event">Event:</a> An Event is an object that the task can register to it by callback when the event invokes -&gt; every registered thread will run the callback.<br />
4. <a href="#time-event">Time event:</a> This object invokes a callback of the task after a specific amount of time.  </p>
<h3 id="polling">Polling</h3>
<p>Every task has its own "main loop", which is a function that has an endless loop (<code>while(1){}</code>), in class <strong>Task</strong> you have an internal function that calls <code>Main_loop()</code>, this function run the endless loop:   </p>
<pre><code>void Task::Main_loop()
{
    while(1)
    {
        Sleep_ms();
    }
}
</code></pre>
<p>If you want you can override this function by your class that inherited <strong>Task</strong> class,<br />
<strong>Important note:</strong> If you override, you must call to function <code>Sleep_ms()</code>, if you don't call it -&gt; other thread can't send your thread messages, also all the events and time events will not invoke your task, the function <code>Sleep_ms()</code> can get parameter of timeout at milliseconds, so every time you want to sleep you can call this function with the time you want to sleep, you can see it in the next example:<br />
Example: in the next example the class ledTask will toggle the led every 500ms:</p>
<pre><code>void LedTask::Main_loop() 
{
    while(1)
    {
        ToggleLed();    
        Sleep_ms(500);
    }
}
</code></pre>
<h3 id="get-message">Get message</h3>
<p>The message is the ability to send messages from one task to a second task, for example, let's assume that we have two tasks: <strong>LedTask</strong> and <strong>TestTask</strong>, we want that TestTask will send to a LedTask message every second, to perform it we will need to do two things:<br />
<strong>1)</strong> The TestTask needs to call to member function <code>bool NotifyMessage()</code> of the LedTask every second, the function returns if the message gets into a queue of the messages of LedTask successfully,  Example:  </p>
<pre><code>void TestTask::Main_loop() 
{
    while(1)
    {
        LedTaskPointer-&gt;NotifyMessage();    
        Sleep_ms(1000);
    }
}
</code></pre>
<p><strong>2)</strong> The LedTask need to override the function <code>void ReceiveMsg(void* pointer)</code>, example:</p>
<pre><code>void LedTask::ReceiveMsg(void* pointer)
{
    printf(&quot;Get message \n&quot;,);
}
</code></pre>
<p>The result of the code above is every second the LedTask will print "Get message"</p>
<p><strong>Important Point:</strong>  </p>
<ul>
<li>Get different messages: If you get more than one type of message (for example: if you have led and you want that LedTask can get a message that turns on the led and a message that turns off the led) it can be a problem because you can't know with type of message you get, to solve that problem you will need to send data in this message and the LedTask need to know to parse the data, I will explain it in section <a href="#send-data-between-tasks">Send data between tasks</a>.</li>
</ul>
<h3 id="event">Event</h3>
<p>An event is an object that the task can register to it by callback, when the event invokes -&gt; every registered thread will run the callback,<br />
For the next example let's assume that we have 2 tasks: <strong>LedTask</strong> and <strong>TestTask</strong>, we want that TestTask has an event that LedTask can register to it and every second the TestTask will invoke the Event.<br />
To do that we need 4 steps:<br />
<strong>1)</strong> Create the event object in TestTask:  </p>
<pre><code>#include &quot;Event.h&quot;

class TestTask : public Task
{
public:
    TestTask();
    void Main_loop();

    Event event;
};
</code></pre>
<p><strong>2)</strong> Create a callback in the LedTask:</p>
<pre><code>class LedTask : public Task
{
public:
    LedTask();
    void Main_loop();
    void Callback(void* param)
    {
        printf(&quot;Event invoke \n&quot;);
    }
};
</code></pre>
<p><strong>Note:</strong> You can change the name of the callback as you like but it must be in the next pattern <code>void &lt;Function name&gt;(void* pointer)</code>  <br />
<strong>3)</strong> Register the LedTask to the event of TestTask:</p>
<pre><code>void LedTask::Main_loop()
{
    TestTaskPointer-&gt;event.Register(&amp;LedTask::Callback, this, this);

    while(1)
        Sleep_ms();
}
</code></pre>
<p><strong>Parameter explain:</strong><br />
The register function of the event gets 3 parameters:<br />
<strong>Function:</strong> Pointer to function.<br />
<strong>Class pointer:</strong> Pointer to the class that has the callback (in my example is a pointer to LedTask)<br />
<strong>Task pointer:</strong> Pointer to the class that is inherited from the task class (in my example is a pointer to LedTask)  </p>
<p><strong>4)</strong> Invoke the event every second:</p>
<pre><code>void TestTask::Main_loop()
{    
    while(1)
    {
        event.Invoke();
        Sleep_ms(1000);
    }        
}
</code></pre>
<p>The result of the code is every second the LedTask will print "Event invoke"</p>
<h3 id="time-event">Time event</h3>
<p>This object invokes a callback of a task after a specific amount of time,
For the next example let's assume that we had one task: <strong>LedTask</strong> and we want to toggle the led every 100ms, to do that we need to perform 2 steps:
<strong>1)</strong> Create callback:</p>
<pre><code>void LedTask::Callback(void* param)
{
    printf(&quot;Toggle led \n&quot;)
}
</code></pre>
<p><strong>Note:</strong> You can change the name of the callback as you like but it must be in the next pattern <code>void &lt;Function name&gt;(void* pointer)</code>  </p>
<p><strong>2)</strong> Create the event:</p>
<pre><code>#include &quot;TimeEvent.h&quot;

void LedTask::Main_loop()
{
    TimeEvent time_event(&amp;LedTask::Callback, this, this, 100, true)
    while(1)
        Sleep_ms();
}
</code></pre>
<p><strong>Parameter explain:</strong><br />
The register function of the time event gets 5 parameters:<br />
<strong>Function:</strong> Pointer to function.<br />
<strong>Class pointer:</strong> Pointer to the class that has the callback (in my example is a pointer to LedTask)<br />
<strong>Task pointer:</strong> Pointer to the class that is inherited from task class (in my example is a pointer to LedTask)<br />
<strong>Time to execute:</strong> The number of milliseconds until the call to callback.<br />
<strong>Is periodic:</strong> Boolean, false - The callback call once, true - call periodic (forever).</p>
<h2 id="send-data-between-tasks">Send data between tasks</h2>
<p>To send data between tasks you have 2 ways:<br />
1. <a href="#send-data-by-message">Message:</a> Send message from one task to other.<br />
2. <a href="#send-data-by-event">Event:</a> Create an event that every task that gets registered by callback, when invoking the event you can also add data and every callback will get the data.</p>
<p>As you can see both methods are also used to run the code by another task.
Here the example of how to implement them:</p>
<h3 id="send-data-by-message">Send data by message</h3>
<p>Send messages from one task to other.
For example, let's assume that we have two tasks: <strong>LedTask</strong> and <strong>TestTask</strong>, we want that TestTask will send to a LedTask message every second, the message will include a counter and the LedTask will print it to perform it we will need to do two things:<br />
<strong>1)</strong> The TestTask need to call to member function <code>bool NotifyMessage(void* pointer)</code> of the LedTask every second, the function returns if the message gets into the queue of the message of LedTask successfully,  Example:  </p>
<pre><code>void TestTask::Main_loop() 
{
    int counter = 0;
    while(1)
    {        
        LedTaskPointer-&gt;NotifyMessage((void*)&amp;counter); 
        Sleep_ms(1000);
        counter++;
    }
}
</code></pre>
<p><strong>2)</strong> The LedTask need to override the function <code>void ReceiveMsg(void* pointer)</code>, example:</p>
<pre><code>void LedTask::ReceiveMsg(void* pointer)
{
    printf(&quot;Counter %d \n&quot;, *(int*)param);
}
</code></pre>
<p>The result of the code above is: every second the LedTask will print "Counter X" where X is the counter.</p>
<h3 id="send-data-by-event">Send data by event</h3>
<p>Create an event that every task that gets registered by callback, when invoking the event you can also add data and every callback will get the data.
For the next example let's assume that we have 2 tasks: <strong>LedTask</strong> and <strong>TestTask</strong>, we want that TestTask has an event that LedTask can register to it and every second the TestTask will invoke the Event, and also send a counter over the event.<br />
To do that we need 4 steps:  </p>
<p><strong>1)</strong> Create the event object in TestTask:  </p>
<pre><code>#include &quot;Event.h&quot;

class TestTask : public Task
{
public:
    TestTask();
    void Main_loop();

    Event event;
};
</code></pre>
<p><strong>2)</strong> Create a callback in the LedTask:</p>
<pre><code>class LedTask : public Task
{
public:
    LedTask();
    void Main_loop();
    void Callback(void* param)
    {
        printf(&quot;Counter %d \n&quot;, *(int*)param);
    }
};
</code></pre>
<p><strong>Note:</strong> You can change the name of the callback as you like but it must be in the next pattern <code>void &lt;Function name&gt;(void* pointer)</code> </p>
<p><strong>3)</strong> Register the LedTask to an event of TestTask:</p>
<pre><code>void LedTask::Main_loop()
{
    TestTaskPointer-&gt;event.Register(&amp;LedTask::Callback, this, this);

    while(1)
        Sleep_ms();
}
</code></pre>
<p><strong>Parameter explain:</strong><br />
The register function of the event gets 3 parameters:<br />
<strong>Function:</strong> Pointer to function.<br />
<strong>Class pointer:</strong> Pointer to the class that has the callback (in my example is a pointer to LedTask)<br />
<strong>Task pointer:</strong> Pointer to the class that is inherited from task class (in my example is a pointer to LedTask)  </p>
<p><strong>4)</strong> Invoke the event every second and send the value of the counter:</p>
<pre><code>void TestTask::Main_loop()
{    
    int counter = 0;

    while(1)
    {
        event.Invoke((void*)&amp;counter);
        Sleep_ms(1000);
        counter++;
    }        
}
</code></pre>
<p>The result of the code is every second the LedTask will print "Counter X" where X is the counter</p>
<h2 id="sleep-suspend">Sleep (Suspend)</h2>
<p>Most of the time we want that the task will be suspended so the others task can run, in ThreadX++ you have serval ways to set the task to sleep.<br />
1. <a href="#sleep-function">Sleep function:</a> Call the function <code>Sleep_ms</code> of class Task.<br />
2. <a href="#wait-for-message">Wait for a message:</a> When you wait for a new message to arrive the task is sleep.<br />
3. <a href="#threadx-api">ThreadX API:</a> mutex, semaphore, queue.</p>
<h3 id="sleep-function">Sleep function</h3>
<p>Call the function <code>Sleep_ms</code> of class Task.</p>
<pre><code>void LedTask::Main_loop()
{
    while(1)
    {
        Sleep_ms(1000);
        Sleep_ms(QUEUE_NO_WAIT);
    }        
}
</code></pre>
<p>Because we override the <code>Main_loop()</code> function we must call to function <code>Sleep_ms()</code>, if we do not call it -&gt; we don't get any message from the other task and the event will not invoke the callback of this task.</p>
<h3 id="wait-for-a-message">Wait for a message</h3>
<p>When you wait for a new message to arrive the task is sleep.</p>
<pre><code>void LedTask::Main_loop()
{
    while(1)
    {        
        Sleep_ms();
    }        
}
</code></pre>
<p>When we call to function <code>Sleep_ms()</code> the task will sleep until it gets a message or invoke by an event, the function also can get the parameter of timeout in milliseconds and when the timeout occurs the task will resume.  </p>
<h3 id="threadx-api">ThreadX API</h3>
<p>When using the API locking mechanism of ThreadX the task will go to sleep:  </p>
<ul>
<li><strong>Mutex:</strong> If we have two task, task1 lock the mutex, than the task2 try to lock, the task2 will sleep until the task1 will unlock the mutex.  </li>
<li><strong>Semaphore:</strong> When we have two task, task1 Put the semaphore, the task1 will sleep until the task2 Get the semaphore.</li>
<li><strong>Queue</strong> When pull from a queue the task goes to sleep</li>
</ul>
<h2 id="singleton">Singleton</h2>
<p>Singleton is a design pattern, if you don't know what is, you can look <a href="https://www.tutorialspoint.com/Explain-Cplusplus-Singleton-design-pattern">here</a>.<br />
This not really part of the <code>task</code> but in my opinion it very helpful because for most of the tasks if not all of them you will be want to be only single of them and have easy access from everywhere,
So I create a class <code>Singleton</code> that can be inherited:</p>
<h3 id="how-to-create">How to create</h3>
<p>In the class that you want to inherit you need to do 3 things:
1. Add <code>#include "Singleton.h"</code>.<br />
2. Inheriting from singleton class: <code>class &lt;class name&gt; : public Singleton&lt;class name&gt;</code>.<br />
3. In the class definition add <code>friend Singleton&lt;class name&gt;</code></p>
<p><strong>Example:</strong> If you want to create task <code>LedTask</code> and you want him to be a singleton, the declaration of the class looks like that:</p>
<pre><code>#include &quot;Task.h&quot;
#include &quot;Singleton.h&quot;

class LedTask : public Task, public Singleton&lt;LedTask&gt;
{
friend Singleton&lt;LedTask&gt;;
private:
    LedTask();
    void ToggleLed();

    static const uint16_t   TASK_PRIORITY   = NORMAL_PRIORITY;
    static const uint16_t   STACK_SIZE      = 1024;
protected:
    virtual void ReceiveMsg(void* pointer);
};
</code></pre>
<h3 id="how-to-use">How to use</h3>
<p>When you want to call to a class that is also singleton you need to do only 2 steps:
1. Add the include of the class.<br />
2. Call to class like that <code>&lt;class name&gt;::Instance-&gt;&lt;someFunction&gt;</code>.</p>
<p><strong>Example:</strong> If we want to call to function <code>NotifyMessage()</code> of the task <code>LedTask</code>:</p>
<pre><code>#include &quot;LedTask.h&quot;

void Some_function()
{
    LedTask::Instance()-&gt;NotifyMessage();
}
</code></pre>
<p><strong>Note:</strong> You can use the singleton on any class (and not only the tasks).</p>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../introduction/" class="btn btn-neutral float-left" title="Introduction"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../threadx_api/" class="btn btn-neutral float-right" title="ThreadX API (Mutex, Semaphore, Queue)">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href="../introduction/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../threadx_api/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script>var base_url = '../..';</script>
    <script src="../../js/theme_extra.js" defer></script>
    <script src="../../js/theme.js" defer></script>
      <script src="../../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
