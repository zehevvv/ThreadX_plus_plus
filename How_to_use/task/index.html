<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../../img/favicon.ico" />
    <title>Task (Thread) - ThreadX++</title>
    <link rel="stylesheet" href="../../css/theme.css" />
    <link rel="stylesheet" href="../../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "Task (Thread)";
        var mkdocs_page_input_path = "How_to_use\\task.md";
        var mkdocs_page_url = null;
      </script>
    
    <script src="../../js/jquery-3.6.0.min.js" defer></script>
    <!--[if lt IE 9]>
      <script src="../../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
      <script>hljs.initHighlightingOnLoad();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../.." class="icon icon-home"> ThreadX++
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../..">Home</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">Install</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../Install/install_st/">Install ThreadX on ST</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../Install/add_threadx_plus_plus/">Add ThreadX++</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">How to use</span></p>
              <ul class="current">
                  <li class="toctree-l1"><a class="reference internal" href="../introduction/">Introduction</a>
                  </li>
                  <li class="toctree-l1 current"><a class="reference internal current" href="./">Task (Thread)</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#introduction">Introduction</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#create-task">Create Task</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#run-code-by-task">Run code by task</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#polling">Polling</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#get-message">Get message</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#event">Event</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#time-event">Time event</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#send-data-between-tasks">Send data between tasks</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#send-data-by-message">Send data by message</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#send-data-by-event">Send data by event</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#sleep-suspend">Sleep (Suspend)</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#sleep-function">Sleep function</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#wait-for-message">Wait for message</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#threadx-api">ThreadX API</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#singleton">Singleton</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#how-to-create">How to create</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#how-to-use">How to use</a>
    </li>
        </ul>
    </li>
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../threadx_api/">ThreadX API (Mutex, Semaphore, Queue)</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../memory_manager/">Memory manager</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Add STM32 API</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../Add_stm32_api/config_printf/">Config printf</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../Add_stm32_api/watchdog/">Watchdog</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../Add_stm32_api/registry/">Registry</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../Add_stm32_api/measure_time/">Measure time</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">About</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../about/">About</a>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../..">ThreadX++</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../.." class="icon icon-home" alt="Docs"></a> &raquo;</li>
          <li>How to use &raquo;</li>
      <li>Task (Thread)</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="task">Task</h1>
<h2 id="introduction">Introduction</h2>
<p>In ThreadX++ the <code>thread</code> are <code>task</code>, so when you create task you actually create thread of ThreadX and how run code by task and send data between data and of course sleep.<br />
Every task created with queue of messages, the messages use for invoke the task by event and send data between tasks.</p>
<h2 id="create-task">Create Task</h2>
<p>In this example we will create LedTask that blink the led every 1 second.
e
<strong>1)</strong> Add the include </p>
<pre><code>#include &quot;Task.h&quot;
</code></pre>
<p><strong>2)</strong> Create a class that inherits from a Task class:</p>
<pre><code class="language-e">class LedTask : public Task
</code></pre>
<p><strong>3)</strong> In the implementation of the constructor you will need to call to constructor of the Task class and enter 3 parameter:<br />
<strong>name:</strong> The name of the task.<br />
<strong>priority:</strong> The priority of the task.<br />
<strong>stack size:</strong> The size of the stack of the task.<br />
<strong>num_message:</strong> The number of messages that the task will hold in the queue, the default argument value is 10.</p>
<p><strong>Example:</strong> We will create task with priority <code>10</code> and stack size <code>1024</code>:</p>
<pre><code>LedTask::LedTask() : Task(&quot;LedTask&quot;, 10, 1024) { }
</code></pre>
<p><strong>4)</strong> Add the LedTask to <code>TaskManager.cpp</code> to function <code>Tasks_manager_start()</code>:</p>
<pre><code>void Tasks_manager_start()
{
    printf(&quot;ThreadX++ start run \n&quot;);

    LedTaskPointer-&gt;StartTask();
}
</code></pre>
<h2 id="run-code-by-task">Run code by task</h2>
<p>We have 4 way to run code from the created task:<br />
1. <a href="#polling">Polling:</a> Function that have endless loop (<code>while(1){}</code>).<br />
2. <a href="#get-message">Get message:</a> A message that send by other thread can invoke the current thread to run specific function.<br />
3. <a href="#event">Event:</a> Event is object that task can register to it by callback, when the event invoke -&gt; every registered thread will run the call back.<br />
4. <a href="#time-event">Time event:</a> This object that invoke callback of task after specific amount of time.  </p>
<h3 id="polling">Polling</h3>
<p>Every task have it's own "main loop", this is a function that have endless loop (<code>while(1){}</code>), in class <strong>Task</strong> you have internal function that call <code>Main_loop()</code>, this function run the endless loop:   </p>
<pre><code>void Task::Main_loop()
{
    while(1)
    {
        WaitForNewMessage();
    }
}
</code></pre>
<p>If you want you can override this function by your class that inherited <strong>Task</strong> class,<br />
<strong>Important note:</strong> If you override, you must call to function <code>WaitForNewMessage()</code>, if you don't call it -&gt; other thread can't send your thread messages, also all the events and time events will not invoke your task, the function <code>WaitForNewMessage()</code> can get parameter of timeout at milliseconds, so every time you want to sleep you can call this function with the time you want to sleep, you can see it in the next example:<br />
Example: in the next example the class ledTask will toggle the led every 500ms:</p>
<pre><code>void LedTask::Main_loop() 
{
    while(1)
    {
        ToggleLed();    
        WaitForNewMessage(500);
    }
}
</code></pre>
<h3 id="get-message">Get message</h3>
<p>The message is the ability to send message from one task to second task, for example, let's assume that we have two task: <strong>LedTask</strong> and <strong>TestTask</strong>, we want that TestTask will send to LedTask message every seconds, in order to preform it we will need to do two things:<br />
<strong>1)</strong> The TestTask need to call to member function <code>bool NotifyMessage()</code> of the LedTask every second, the function return if the message get into queue of message of LedTask successfully,  Example:  </p>
<pre><code>void TestTask::Main_loop() 
{
    while(1)
    {
        LedTaskPointer-&gt;NotifyMessage();    
        WaitForNewMessage(1000);
    }
}
</code></pre>
<p><strong>2)</strong> The LedTask need to override the function <code>void ReceiveMsg(void* pointer)</code>, example:</p>
<pre><code>void LedTask::ReceiveMsg(void* pointer)
{
    printf(&quot;Get message \n&quot;,);
}
</code></pre>
<p>The result of code above is: every second the LedTask will print "Get message"</p>
<p><strong>Important Point:</strong>  </p>
<ul>
<li>Get different messages: If you get more than one type of message (for example: if you have led and you want that LedTask can get message that turn on the led and message that turn off the led) it can be a problem because you can't know with type of message you get, to solve that problem you will need to send data in this message and the LedTask need to know to parse the data, I will explain it in section <a href="#send-data-between-tasks">Send data between tasks</a>.</li>
</ul>
<h3 id="event">Event</h3>
<p>Event is object that task can register to it by callback, when the event invoke -&gt; every registered thread will run the call back,<br />
For the next example let assume that we have 2 task: <strong>LedTask</strong> and <strong>TestTask</strong>, we want that TestTask have event that LedTask can register to it and every one second the TestTask will invoke the Event.<br />
Todo that we need 4 steps:<br />
<strong>1)</strong> Create the event object in TestTask:  </p>
<pre><code>#include &quot;Event.h&quot;

class TestTask : public Task
{
public:
    TestTask();
    void Main_loop();

    Event event;
};
</code></pre>
<p><strong>2)</strong> Create callback in the LedTask:</p>
<pre><code>class LedTask : public Task
{
public:
    LedTask();
    void Main_loop();
    void Callback(void* param)
    {
        printf(&quot;Event invoke \n&quot;);
    }
};
</code></pre>
<p><strong>Note:</strong> You can change the name of the callback as you like but it must be in the next pattern <code>void &lt;Function name&gt;(void* pointer)</code>  <br />
<strong>3)</strong> Register the LedTask to event of TestTask:</p>
<pre><code>void LedTask::Main_loop()
{
    TestTaskPointer-&gt;event.Register(&amp;LedTask::Callback, this, this);

    while(1)
        WaitForNewMessage();
}
</code></pre>
<p><strong>Parameter explain:</strong><br />
The register function of the event get 3 parameters:<br />
<strong>Function:</strong> Pointer to function.<br />
<strong>Class pointer:</strong> Pointer to class that have the callback (in my example is pointer to LedTask)<br />
<strong>Task pointer:</strong> Pointer to class that inherited from task class (in my example is pointer to LedTask)  </p>
<p><strong>4)</strong> Invoke the event every one second:</p>
<pre><code>void TestTask::Main_loop()
{    
    while(1)
    {
        event.Invoke();
        WaitForNewMessage(1000);
    }

}
</code></pre>
<p>The result of the code is every second the LedTask will print "Event invoke"</p>
<h3 id="time-event">Time event</h3>
<p>This object that invoke callback of task after specific amount of time,
For next example let's assume that we had one task: <strong>LedTask</strong> and we want to toggle the led every 100ms, to do that we need to preform 2 steps:
<strong>1)</strong> Create callback:</p>
<pre><code>void LedTask::Callback(void* param)
{
    printf(&quot;Toggle led \n&quot;)
}
</code></pre>
<p><strong>Note:</strong> You can change the name of the callback as you like but it must be in the next pattern <code>void &lt;Function name&gt;(void* pointer)</code>  </p>
<p><strong>2)</strong> Create the event:</p>
<pre><code>#include &quot;TimeEvent.h&quot;

void LedTask::Main_loop()
{
    TimeEvent time_event(&amp;LedTask::Callback, this, this, 100, true)
    while(1)
        WaitForNewMessage();
}
</code></pre>
<p><strong>Parameter explain:</strong><br />
The register function of the time event get 5 parameters:<br />
<strong>Function:</strong> Pointer to function.<br />
<strong>Class pointer:</strong> Pointer to class that have the callback (in my example is pointer to LedTask)<br />
<strong>Task pointer:</strong> Pointer to class that inherited from task class (in my example is pointer to LedTask)<br />
<strong>Time to execute:</strong> The number of milliseconds until call to callback.<br />
<strong>Is periodic:</strong> Boolean, false - The callback call once, true - call periodic (forever).</p>
<h2 id="send-data-between-tasks">Send data between tasks</h2>
<p>To send data between tasks you have 2 ways:<br />
1. <a href="#send-data-by-message">Message:</a> Send message from one task to other.<br />
2. <a href="#send-data-by-event">Event:</a> Create event that every task get register by callback, when invoke the event you can also add data and every callback will get the data.</p>
<p>As you can see the both method also used to run code by other task.
Here the example how to implement them:</p>
<h3 id="send-data-by-message">Send data by message</h3>
<p>Send message from one task to other.
For example, let's assume that we have two task: <strong>LedTask</strong> and <strong>TestTask</strong>, we want that TestTask will send to LedTask message every seconds, the message will include counter and the LedTask will print it in order to preform it we will need to do two things:<br />
<strong>1)</strong> The TestTask need to call to member function <code>bool NotifyMessage(void* pointer)</code> of the LedTask every second, the function return if the message get into queue of message of LedTask successfully,  Example:  </p>
<pre><code>void TestTask::Main_loop() 
{
    int counter = 0;
    while(1)
    {        
        LedTaskPointer-&gt;NotifyMessage((void*)&amp;counter); 
        WaitForNewMessage(1000);
        counter++;
    }
}
</code></pre>
<p><strong>2)</strong> The LedTask need to override the function <code>void ReceiveMsg(void* pointer)</code>, example:</p>
<pre><code>void LedTask::ReceiveMsg(void* pointer)
{
    printf(&quot;Counter %d \n&quot;, *(int*)param);
}
</code></pre>
<p>The result of code above is: every second the LedTask will print "Counter X" where X is the counter.</p>
<h3 id="send-data-by-event">Send data by event</h3>
<p>Create event that every task get register by callback, when invoke the event you can also add data and every callback will get the data.
For the next example let assume that we have 2 task: <strong>LedTask</strong> and <strong>TestTask</strong>, we want that TestTask have event that LedTask can register to it and every one second the TestTask will invoke the Event, and also send counter over the event.<br />
Todo that we need 4 steps:  </p>
<p><strong>1)</strong> Create the event object in TestTask:  </p>
<pre><code>#include &quot;Event.h&quot;

class TestTask : public Task
{
public:
    TestTask();
    void Main_loop();

    Event event;
};
</code></pre>
<p><strong>2)</strong> Create callback in the LedTask:</p>
<pre><code>class LedTask : public Task
{
public:
    LedTask();
    void Main_loop();
    void Callback(void* param)
    {
        printf(&quot;Counter %d \n&quot;, *(int*)param);
    }
};
</code></pre>
<p><strong>Note:</strong> You can change the name of the callback as you like but it must be in the next pattern <code>void &lt;Function name&gt;(void* pointer)</code> </p>
<p><strong>3)</strong> Register the LedTask to event of TestTask:</p>
<pre><code>void LedTask::Main_loop()
{
    TestTaskPointer-&gt;event.Register(&amp;LedTask::Callback, this, this);

    while(1)
        WaitForNewMessage();
}
</code></pre>
<p><strong>Parameter explain:</strong><br />
The register function of the event get 3 parameters:<br />
<strong>Function:</strong> Pointer to function.<br />
<strong>Class pointer:</strong> Pointer to class that have the callback (in my example is pointer to LedTask)<br />
<strong>Task pointer:</strong> Pointer to class that inherited from task class (in my example is pointer to LedTask)  </p>
<p><strong>4)</strong> Invoke the event every one second and send the value of the counter:</p>
<pre><code>void TestTask::Main_loop()
{    
    int counter = 0;

    while(1)
    {
        event.Invoke((void*)&amp;counter);
        WaitForNewMessage(1000);
        counter++;
    }        
}
</code></pre>
<p>The result of the code is every second the LedTask will print "Counter X" where X is the counter</p>
<h2 id="sleep-suspend">Sleep (Suspend)</h2>
<p>Most of the time we want that the task will be suspend so the others task can run, in ThreadX++ you have serval way to set the task to sleep.<br />
1. <a href="#sleep-function">Sleep function:</a> Call the function <code>Sleep_ms</code> of class Task.<br />
2. <a href="#wait-for-message">Wait for message:</a> When you wait to new message to arrive the task is sleep.<br />
3. <a href="#threadx-api">ThreadX API:</a> mutex, semaphore, queue.</p>
<h3 id="sleep-function">Sleep function</h3>
<p>Call the function <code>Sleep_ms</code> of class Task.</p>
<pre><code>void LedTask::Main_loop()
{
    while(1)
    {
        Sleep_ms(1000);
        WaitForNewMessage(QUEUE_NO_WAIT);
    }        
}
</code></pre>
<p>Because we override the <code>Main_loop()</code> function we must call to function <code>WaitForNewMessage()</code>, if we not call it -&gt; we don't get message from other task and the event will not invoke the callback of this task.</p>
<h3 id="wait-for-message">Wait for message</h3>
<p>When you wait to new message to arrive the task is sleep.</p>
<pre><code>void LedTask::Main_loop()
{
    while(1)
    {        
        WaitForNewMessage();
    }        
}
</code></pre>
<p>When we call to function <code>WaitForNewMessage()</code> the task will sleep until it get message or invoke by event, the function also can get parameter of timeout in millisecond and when the timeout occur the task will resume.  </p>
<h3 id="threadx-api">ThreadX API</h3>
<p>When using the API locking mechanism of ThreadX the task will go to sleep:  </p>
<ul>
<li><strong>Mutex:</strong> If we have two task, task1 lock the mutex, than the task2 try to lock, the task2 will sleep until the task1 will unlock the mutex.  </li>
<li><strong>Semaphore:</strong> When we have two task, task1 Put the semaphore, the task1 will sleep until the task2 Get the semaphore.</li>
<li><strong>Queue</strong> When pull from queue the task go to sleep</li>
</ul>
<h2 id="singleton">Singleton</h2>
<p>Singleton is a design pattern, if you don't now what is you can look <a href="https://www.tutorialspoint.com/Explain-Cplusplus-Singleton-design-pattern">here</a>.<br />
This not really part of <code>task</code> but for my opinion it very helpful because most of task if not all of them you will be want to be only single of them and easy access from every ever,
So i create class <code>Singleton</code> that can inherited:</p>
<h3 id="how-to-create">How to create</h3>
<p>In the class that you want to inherited you need to do 3 thing:
1. Add <code>#include "Singleton.h"</code>.<br />
2. Inheriting from singleton class: <code>class &lt;class name&gt; : public Singleton&lt;class name&gt;</code>.<br />
3. In the class definition add <code>friend Singleton&lt;class name&gt;</code></p>
<p><strong>Example:</strong> If you want to create task <code>LedTask</code> and you want him to be singleton, the declaration of the class look like that:</p>
<pre><code>#include &quot;Task.h&quot;
#include &quot;Singleton.h&quot;

class LedTask : public Task, public Singleton&lt;LedTask&gt;
{
friend Singleton&lt;LedTask&gt;;
private:
    LedTask();
    void ToggleLed();

    static const uint16_t   TASK_PRIORITY   = NORMAL_PRIORITY;
    static const uint16_t   STACK_SIZE      = 1024;
protected:
    virtual void ReceiveMsg(void* pointer);
};

</code></pre>
<h3 id="how-to-use">How to use</h3>
<p>When you want to call to class that also singleton you need to do only 2 steps:
1. Add the include of the class.<br />
2. Call to class like that <code>&lt;class name&gt;::Instance-&gt;&lt;someFunction&gt;</code>.</p>
<p><strong>Example:</strong> If we want to call to function <code>NotifyMessage()</code> of the task <code>LedTask</code>:</p>
<pre><code>#include &quot;LedTask.h&quot;

void Some_function()
{
    LedTask::Instance()-&gt;NotifyMessage();
}
</code></pre>
<p><strong>Note:</strong> You can use the singleton on any class (and not only the tasks).</p>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../introduction/" class="btn btn-neutral float-left" title="Introduction"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../threadx_api/" class="btn btn-neutral float-right" title="ThreadX API (Mutex, Semaphore, Queue)">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href="../introduction/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../threadx_api/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script>var base_url = '../..';</script>
    <script src="../../js/theme_extra.js" defer></script>
    <script src="../../js/theme.js" defer></script>
      <script src="../../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
